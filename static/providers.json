[
  {
    "name": "openlibrary",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://openlibrary.org/static/openapi.json",
    "content_type": "application/json",
    "metadata": {
      "description": "Open Library API for accessing book information and catalog data",
      "category": "Books & Literature",
      "last_updated": "2024-01-15",
      "maintainer": "Internet Archive",
      "documentation_url": "https://openlibrary.org/developers/api"
    }
  },
  {
    "name": "newsapi",
    "provider_type": "text",
    "file_path": "./newsapi_manual.json",
    "metadata": {
      "description": "News API for accessing current and historic news articles",
      "category": "News & Media",
      "last_updated": "2024-01-10",
      "maintainer": "NewsAPI.org",
      "documentation_url": "https://newsapi.org/docs"
    }
  },
  {
    "name": "openai",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/openai/openai-openapi/refs/heads/manual_spec/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "OpenAI API for accessing GPT models and AI capabilities",
      "category": "AI & Machine Learning",
      "last_updated": "2024-01-20",
      "maintainer": "OpenAI",
      "documentation_url": "https://platform.openai.com/docs"
    }
  },
  {
    "name": "github",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/github/rest-api-description/main/descriptions/api.github.com/api.github.com.json",
    "content_type": "application/json",
    "metadata": {
      "description": "GitHub REST API for repositories, users, issues, and more",
      "category": "Development & Version Control",
      "last_updated": "2025-01-01",
      "maintainer": "GitHub",
      "documentation_url": "https://docs.github.com/en/rest"
    }
  },
  {
    "name": "pokeapi",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/pokeapi.co/2.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "RESTful Pokémon API with data about Pokémon, moves, abilities, and more",
      "category": "Gaming & Entertainment",
      "last_updated": "2024-12-01",
      "maintainer": "PokéAPI",
      "documentation_url": "https://pokeapi.co/docs/v2"
    }
  },
  {
    "name": "stripe",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/stripe.com/2020-08-27/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Stripe payment processing API for online payments and billing",
      "category": "Payments & Finance",
      "last_updated": "2024-11-15",
      "maintainer": "Stripe",
      "documentation_url": "https://stripe.com/docs/api"
    }
  },
  {
    "name": "weatherapi",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/weatherapi.com/1.0.2/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Weather API providing current weather, forecasts, and historical data",
      "category": "Weather & Climate",
      "last_updated": "2024-10-20",
      "maintainer": "WeatherAPI",
      "documentation_url": "https://www.weatherapi.com/docs/"
    }
  },
  {
    "name": "jsonplaceholder",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/jsonplaceholder.typicode.com/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Fake REST API for testing and prototyping with posts, users, and comments",
      "category": "Development & Testing",
      "last_updated": "2024-08-15",
      "maintainer": "JSONPlaceholder",
      "documentation_url": "https://jsonplaceholder.typicode.com/"
    }
  },
  {
    "name": "restcountries",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/restcountries.com/3.1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "REST Countries API providing information about all countries",
      "category": "Geography & Travel",
      "last_updated": "2024-09-10",
      "maintainer": "REST Countries",
      "documentation_url": "https://restcountries.com/"
    }
  },
  {
    "name": "petstore",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/swagger-api/swagger-petstore/master/src/main/resources/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Swagger Petstore sample API for learning OpenAPI specification",
      "category": "Examples & Samples",
      "last_updated": "2024-07-01",
      "maintainer": "Swagger API",
      "documentation_url": "https://petstore.swagger.io/"
    }
  },
  {
    "name": "alerter_system_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/alertersystem.com/1.7.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is the Alerter System API playground. More documentation is available at the API Help Center.The \"Available Authorizations\" in the Authorize popup only applies to this playground web interface. Other authorizations are available for the actual API.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "alertersystem.com",
      "documentation_url": "https://alertersystem.com",
      "version": "1.7.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Alerter System API",
      "paths_count": 186,
      "schemas_count": 576
    }
  },
  {
    "name": "anchore_engine_api_server",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/anchore.io/0.1.20/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is the Anchore Engine API. Provides the primary external API for users of the service.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "anchore.io",
      "documentation_url": "https://anchore.io",
      "version": "0.1.20",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Anchore Engine API Server",
      "paths_count": 75,
      "schemas_count": 149
    }
  },
  {
    "name": "apacta",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/apacta.com/0.0.42/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "API for a tool to craftsmen used to register working hours, material usage and quality assurance. Endpoint The endpoint https://app.apacta.com/api/v1 should be used to communicate with the API. API access is only allowed with SSL encrypted connection (https). Authentication URL query authentication with an API key is used, so appending ?api_key={api_key} to the URL where {api_key} is found within Apacta settings is used for authentication Pagination If the endpoint returns a pagination object it means the endpoint supports pagination - currently it's only possible to change pages with ?page={page_number} but implementing custom page sizes are on the road map. Search/filter Is experimental but implemented in some cases - see the individual endpoints' docs for further explanation. Ordering Is currently experimental, but on some endpoints it's implemented on URL querys so eg. to order Invoices by invoice_number appending ?sort=Invoices.invoice_number&direction=desc would sort the list descending by the value of invoice_number. Associations Is currently implemented on an experimental basis where you can append eg. ?include=Contacts,Projects to the /api/v1/invoices/ endpoint to embed Contact and Project objects directly. Project Files Currently project files can be retrieved from two endpoints. /projects/{project_id}/files handles files uploaded from wall posts or forms. /projects/{project_id}/project_files allows uploading and showing files, not belonging to specific form or wall post. Errors/Exceptions 422 (Validation) Write something about how the errors object contains keys with the properties that failes validation like: Code examples Running examples of how to retrieve the 5 most recent forms registered and embed the details of the User that made the form, and eventual products contained in the form Swift Java OkHttp Unirest Javascript Native jQuery NodeJS (Request) Python 3 C# RestSharp Ruby PHP (HttpRequest) Shell (cURL)",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "apacta.com",
      "documentation_url": "https://apacta.com",
      "version": "0.0.42",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Apacta",
      "paths_count": 185,
      "schemas_count": 90
    }
  },
  {
    "name": "api_video",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/api.video/1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "api.video is an API that encodes on the go to facilitate immediate playback, enhancing viewer streaming experiences across multiple devices and platforms. You can stream live or on-demand online videos within minutes.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "api.video",
      "documentation_url": "https://api.video",
      "version": "1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "api.video",
      "paths_count": 26,
      "schemas_count": 70
    }
  },
  {
    "name": "swagger_api2cart",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/api2cart.com/1.1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "API2Cart",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "api2cart.com",
      "documentation_url": "http://docs.api2cart.com",
      "version": "1.1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Swagger API2Cart",
      "paths_count": 147,
      "schemas_count": 143
    }
  },
  {
    "name": "api2pdf_pdf_generation_powered_by_aws_lambda",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/api2pdf.com/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Introduction Api2Pdf is a powerful PDF generation API with no rate limits or file size constraints. Api2Pdf runs on AWS Lambda, a serverless architecture powered by Amazon to scale to millions of requests while being up to 90% cheaper than alternatives. Supports wkhtmltopdf, Headless Chrome, LibreOffice, and PDF Merge. You can also generate barcodes with ZXING (Zebra Crossing). SDKs & Client Libraries We've made a number of open source libraries available for the API - Python: https://github.com/api2pdf/api2pdf.python - .NET: https://github.com/api2pdf/api2pdf.dotnet - Nodejs: https://github.com/api2pdf/api2pdf.node - PHP: https://github.com/Api2Pdf/api2pdf.php - Ruby: (Coming soon) Authorization Create an account at portal.api2pdf.com to get an API key. Authorize your API calls - GET requests, include apikey=YOUR-API-KEY as a query string parameter - POST requests, add Authorization to your header. Quickstart If you are looking for just a quick call to grab PDFs of a URL, you can do a GET request like: For more advanced usage and settings, see the API specification below.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Support",
      "documentation_url": "https://www.api2pdf.com",
      "version": "1.0.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Api2Pdf - PDF Generation, Powered by AWS Lambda",
      "paths_count": 7,
      "schemas_count": 10
    }
  },
  {
    "name": "app_center_client",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/appcenter.ms/v0.1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Microsoft Visual Studio App Center API",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "appcenter.ms",
      "documentation_url": "https://appcenter.ms",
      "version": "v0.1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "App Center Client",
      "paths_count": 266,
      "schemas_count": 783
    }
  },
  {
    "name": "powertools_developer",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/apptigent.com/2021.1.01/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Apptigent PowerTools Developer Edition is a powerful suite of API endpoints for custom applications running on any stack. Manipulate text, modify collections, format dates and times, convert currency, perform advanced mathematical calculations, shorten URL's, encode strings, convert text to speech, translate content into multiple languages, process images, and more. PowerTools is the ultimate developer toolkit.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Customer Support",
      "documentation_url": "https://www.apptigent.com/help/",
      "version": "2021.1.01",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "PowerTools Developer",
      "paths_count": 88,
      "schemas_count": 69
    }
  },
  {
    "name": "appveyor_rest_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/appveyor.com/1.0.0/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "AppVeyor is a hosted continuous integration service which runs on Microsoft Windows. The AppVeyor REST API provides a RESTful way to interact with the AppVeyor service. This includes managing projects, builds, deployments, and the teams that build them. Additional help and discussion of the AppVeyor REST API is available at http://help.appveyor.com/discussions This Swagger definition is an unofficial description of the AppVeyor REST API maintained at https://github.com/kevinoid/appveyor-swagger Please report any issues or suggestions for this Swagger definition at https://github.com/kevinoid/appveyor-swagger/issues/new API Conventions Fields which are missing from update operations (PUT requests) are typically reset to their default values. So although most fields are not technically required, they should usually be specified in practice.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "AppVeyor Team",
      "documentation_url": "https://www.appveyor.com/docs/api/",
      "version": "1.0.0",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "AppVeyor REST API",
      "paths_count": 37,
      "schemas_count": 99
    }
  },
  {
    "name": "art19_content_api_documentation",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/art19.com/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The ART19 Content API conforms to the JSON:API specification. API requests MUST use the HTTP Accept header: Accept: application/vnd.api+json API requests MUST be authenticated using the HTTP Authorization header: Authorization: Token token=\"your-token\", credential=\"your-credential\" General Notes Some query parameters use unencoded [ and ] characters simply for readability. Defaults, examples, and possible values are additionally rendered in double quotes for readability. In practice, query parameters should not have quotes around the values (e.g., foo=bar is valid, not foo=\"bar\"), and both query parameter keys and values must be percent-encoded, per the requirements in RFC 3986 § 3.4. Rate Limiting In order to provide a fair distribution of available resources, all API calls are subject to rate limits. If you exceed the number of API calls per minute granted to your credential, a 429 Too Many Requests error response will be returned. In that case, a Retry-After header MAY be included in the response, describing the number of seconds after which a request can be retried. If you run into a high number of 429 errors, please reach out to ART19 Support to adjust your rate limit. Example In the following example the request can be retried after waiting for 21 seconds: HTTP/1.1 429 Too Many Requests Content-Type: text/html Retry-After: 21 Pagination Requests to collection endpoints SHOULD provide pagination parameters. Some endpoints REQUIRE pagination parameters to be provided. Whenever pagination is provided, it MUST be valid. Failing to provide pagination when it is required or providing wrong or incomplete pagination always results in a 400 Bad Request error response. The page numbering starts with 1 and the maximum page size (if not otherwise documented on an endpoint) is 100. Pagination MUST NOT be specified if requesting a list of IDs (using an ids[] parameter). Providing invalid values for page number or page size, as well as providing only a page number or only a page size, is considered an error. Pagination is provided like this: page[number]=1&page[size]=25 Responses conform to the JSON:API specification's pagination section by including pagination links. Your requested page size will be carried into the pagination links. Sorting Requests to collection endpoints usually accept a sort parameter. Please refer to the JSON:API Specification's sorting section for further details. Relationship Linking Currently, resources return all of their relationships, in no particular order, pursuant to how relationships should be returned according to the JSON:API specification. Consumers of this API MUST NOT make assumptions about the order of these collections. Even though this data is not currently paginated, consumers MUST support paginating relationships per the JSON:API specification if this data is important for their application.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "ART19 Engineering Team",
      "documentation_url": "https://art19.com",
      "version": "1.0.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "ART19 Content API Documentation",
      "paths_count": 22,
      "schemas_count": 13
    }
  },
  {
    "name": "asana",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/asana.com/1.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is the interface for interacting with the Asana Platform. Our API reference is generated from our [OpenAPI spec] (https://raw.githubusercontent.com/Asana/developer-docs/master/defs/asana_oas.yaml).",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Asana Support",
      "documentation_url": "https://asana.com/support",
      "version": "1.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Asana",
      "paths_count": 126,
      "schemas_count": 165
    }
  },
  {
    "name": "business_registries",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/ato.gov.au/0.0.6/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Introduction The Business Registries API is built on HTTP. The API is RESTful. It has predictable resource URIs. The API is documented in OpenAPI format. In addition to the standard OpenAPI syntax we use a few vendor extensions. Overview The following sections describe the resources that make up the Business Registries REST API. Current Version By default, all requests to https://api.abr.ato.gov.au receive the v1 version of the REST API. We encourage you to explicitly request this version via the Accept header. Accept: application/vnd.abr-ato.v1+json Schema All API access is over HTTPS, and accessed from https://api.abr.ato.gov.au. All data is sent and received as JSON. Blank fields are included. All dates use the ISO 8601 format: YYYY-MM-DD For example: 2017-07-01 (the 1st of July 2017) All timestamps use the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ For example: 2017-07-01T11:05:06+10:00 Timezones Some requests allow for specifying timestamps or generate timestamps with time zone information. We apply the following rules, in order of priority, to determine timezone information for API calls. Explicitly provide an ISO 8601 timestamp with timezone information For API calls that allow for a timestamp to be specified, we use that exact timestamp. For example: 2017-07-01T11:05:06+10:00 Pagination Information about pagination is provided in the Link header. For example: Link: ; rel=\"next\", ; rel=\"last\" rel=\"next\" states that the next page is page=2. This makes sense, since by default, all paginated queries start at page 1. rel=\"last\" provides some more information, stating that the last page of results is on page 34. Accordingly, we have 33 more pages of information that we can consume. Parameters Many API methods take optional parameters: GET /individuals/1234/addresses/?addressType='Mailing' In this example, the '1234' value is provided for the :partyId parameter in the path while :addressType is passed in the query string. For POST, PATCH, PUT, and DELETE requests, parameters not included in the URL should be encoded as JSON with a Content-Type of 'application/json'. Metadata The API provides metadata services that you can use to discover information about the classifcation schemes and values used by the Registry. For example: GET /classifications/roles Sample response: [ { \"id\": \"123e4567-e89b-12d3-a456-426655440001\", \"role\": \"Director\", \"roleDescription\": \"An individual responsible for managing a company's ...\", \"relationship\": \"Directorship\", \"reciprocalRole\": \"Company\", \"reciprocalRoleDescription\": \"An incorporated legal entity.\" }, { ... } ] Root Endpoint You can issue a GET request to the root endpoint (also known as the service root) to get all the endpoint categories that the REST API supports: curl https://api.abr.ato.gov.au Authentication The Business Registries API supports API Key authentication. When you sign up for an account, you are given your first API key. You can generate additional API keys, and delete API keys (as you may need to rotate your keys in the future). You authenticate to the Business Registries API by providing your secret key in the request header. Note: Some requests will return 404 Not Found, instead of 403 Permission Denied. This is to prevent the accidental leakage of information to unauthorised users.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "ato.gov.au",
      "documentation_url": "https://ato.gov.au",
      "version": "0.0.6",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Business Registries",
      "paths_count": 38,
      "schemas_count": 35
    }
  },
  {
    "name": "authentiq_connect_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/authentiq.io/1.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Authentiq Connect OAuth 2.0 and OpenID Connect API reference. Learn about Authentiq ID or check out the Authentiq Connect developer documentation.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Team Authentiq",
      "documentation_url": "https://developers.authentiq.com/",
      "version": "1.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Authentiq Connect API",
      "paths_count": 6,
      "schemas_count": 7
    }
  },
  {
    "name": "cis_automotive_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/autodealerdata.com/1.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This API provides access to our Automotive Data. Use of this API is subject to our Terms of Service &nbsp; For a quick start guide click here &nbsp; If you signed up through RapidAPI make your test calls here &nbsp; The general workflow is to: &nbsp;1. Authenticate with your CIS Automotive API Keys to get a Json Web Token (JWT). Do not use RapidAPI keys. 2. Then use that token as an argument when calling other endpoints. &nbsp; Equivalent HTTP GET and POST methods are available for some endpoints. &nbsp; Endpoints may appear more than once on this page if they are associated with multiple tags. eg \"Sales Data\", \"Premium\", \"Pro Plan or Greater\" To see which endpoints are included in different plans look under the \"X Plan or Greater\" tags for the respective plan name. &nbsp; If you signed up for our API through RapidAPI you can make your test calls on their platform. Your RapidAPI credentials will not work on this page. Do not use your RapidAPI keys on this page. If you signed up with us and have an account, you must first authenticate with your API Keys and retrieve a Json Web Token (JWT) from the /getToken endpoint to access the other endpoints. Your JWT is a required argument to all endpoints.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "autodealerdata.com",
      "documentation_url": "https://autodealerdata.com",
      "version": "1.0",
      "openapi_version": "3.0.2",
      "quality_score": 100,
      "is_popular": false,
      "title": "CIS Automotive API",
      "paths_count": 34,
      "schemas_count": 31
    }
  },
  {
    "name": "avaza_api_documentation",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/avaza.com/v1/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Welcome to the autogenerated documentation & test tool for Avaza's API. API Security & AuthenticationAuthentication options include OAuth2 Implicit and Authorization Code flows, and Personal Access Token. All connections should be encrypted over SSL/TLS You can set up and manage your api authentication credentials from within your Avaza account. (requires Administrator permissions on your Avaza account). OAuth2 Authorization endpoint: https://any.avaza.com/oauth2/authorize OAuth2 Token endpoint: https://any.avaza.com/oauth2/tokenBase URL for subsequent API Requests: https://api.avaza.com/ Blogpost about authenticating with Avaza's API: https://www.avaza.com/avaza-api-oauth2-authentication/ Blogpost on using Avaza's webhooks: https://www.avaza.com/avaza-api-webhook-notifications/The OAuth flow currently issues Access Tokens that last 1 day, and Refresh tokens that last 180 daysThe Api respects the security Roles assigned to the authenticating Avaza user and filters the data return appropriately. SupportFor API Support, and to request access please contact Avaza Support Team via our support chat. User Contributed Libraries:Graciously contributed by 3rd party users like you. Note these are not tested or endorsesd by Avaza. We encourage you to review before use, and use at own risk. - PHP OAuth Client Package for Azava API (by Debiprasad Sahoo)",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "avaza.com",
      "documentation_url": "https://avaza.com",
      "version": "v1",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Avaza API Documentation",
      "paths_count": 58,
      "schemas_count": 132
    }
  },
  {
    "name": "bbc_nitro_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/bbc.com/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "BBC Nitro is the BBC's application programming interface (API) for BBC Programmes Metadata.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Open Nitro Project",
      "documentation_url": "https://developer.bbc.co.uk/nitro",
      "version": "1.0.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "BBC Nitro API",
      "paths_count": 25,
      "schemas_count": 219
    }
  },
  {
    "name": "bbc_iplayer_business_layer",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/bbci.co.uk/1.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The definitive iPlayer API.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Open iBL Project",
      "documentation_url": "http://smethur.st/posts/176135860",
      "version": "1.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "BBC iPlayer Business Layer",
      "paths_count": 30,
      "schemas_count": 19
    }
  },
  {
    "name": "beezup_merchant_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/beezup.com/2.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The REST API of BeezUP system Overview The REST APIs provide programmatic access to read and write BeezUP data. Basically, with this API you will be able to do everything like you were with your browser on https://go.beezup.com ! The main features are: - Register and manage your account - Create and manage and share your stores with your friends/co-workers. - Import your product catalog and schedule the auto importation - Search the channels your want to use - Configure your channels for your catalogs to export your product information: - cost and general settings - category and columns mappings - your will be able to create and manage your custom column - put in place exlusion filters based on simple conditions on your product data - override product values - get product vision for a channel catalog scope - Analyze and optimize your performance of your catalogs on all yours channels with different type of reportings by day, channel, category and by product. - Automatize your optimisation by using rules! - And of course... Manage your orders harvested from all your marketplaces: - Synchronize your orders in an uniformized way - Get the available actions and update the order status - ...and more! Authentication credentials The public API with the base path /v2/public have been put in place to give you an entry point to our system for the user registration, login and lost password. The public API does not require any credentials. We give you the some public list of values and public channels for our public commercial web site www.beezup.com. The user API with the base path /v2/user requires a token which is available on this page: https://go.beezup.com/Account/MyAccount Things to keep in mind API Rate Limits - The BeezUP REST API is limited to 100 calls/minute. Media type The default media type for requests and responses is application/json. Where noted, some operations support other content types. If no additional content type is mentioned for a specific operation, then the media type is application/json. Required content type The required and default encoding for the request and responses is UTF8. Required date time format All our date time are formatted in ISO 8601 format: 2014-06-24T16:25:00Z. Base URL The Base URL of the BeezUP API Order Management REST API conforms to the following template. https://api.beezup.com All URLs returned by the BeezUP API are relative to this base URL, and all requests to the REST API must use this base URL template. You can test our API on https://api-docs.beezup.com/swagger-ui\\\\ You can contact us on gitter, #BeezUP/API",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "beezup.com",
      "documentation_url": "https://api-docs.beezup.com/",
      "version": "2.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "BeezUP Merchant API ",
      "paths_count": 195,
      "schemas_count": 834
    }
  },
  {
    "name": "betfair_exchange_streaming_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/betfair.com/1.0.1423/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "API to receive streamed updates. This is an ssl socket connection of CRLF delimited json messages (see RequestMessage & ResponseMessage)",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "BDP Support",
      "documentation_url": "https://developer.betfair.com/support/",
      "version": "1.0.1423",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Betfair: Exchange Streaming API",
      "paths_count": 1,
      "schemas_count": 26
    }
  },
  {
    "name": "budgea_api_documentation",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/biapi.pro/2.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Budgea Development Guides Welcome to Budgea's documentation. This documentation is intended to get you up-and-running with our APIs and advise on the implementation of some regulatory aspects of your application, following the DSP2's guidelines. Getting Started IMPORTANT Depending on your status with regard of the DSP2 regulation, agent or partner, you may call our APIs or simply use our Webview and callbacks to get the financial data of your users. As an agent, you are allowed to call directly our APIs and implement your own form to get the user's credentials. As a partner, you cannot manipulate the credentials, and have to delegate this step to us through our webview. The sections below will document how to use our APIs, make sure you have the agent status to do so. For the partner, please refer to the section Webview and Callbacks of this documentation. Overview Your API is a REST API which requires a communication through https to send and receive JSON documents. During your tests, we recommend to make calls to the API with curl or any other HTTP client of your choice. You can watch a video demonstration on this URL. For the examples we'll use the demo API with address https://demo.biapi.pro, you should change that name to your API's name. Hello World Let's start by calling the service /banks which lists all available banks. To log in to a bank webpage, you'll need to know for a given bank, the fields your user should fill in the form. Let's call a specific bank and ask for an additional resource fields. The response here concerns only 1 bank (since we specified an id) and the resource _Fields_ is added to the response thanks to the query parameter expand. To get more interesting things done, you'll need to send authenticated requests. Authentication The way to authenticate is by passing the Authorization: Bearer header in your request. At the setup a _manage token_ have been generated, you can use this token for now, when creating your user we'll see how to generate a user's token. This endpoint will list all the parameters you can change to adapt Budgea to your needs. We've covered the very first calls. Before diving deeper, let's see some general information about the APIs. Abstract API URL https://demo.biapi.pro/2.0 Requests format Data format: application/x-www-form-urlencoded or application/json (suggested) Additional headers: Authorization: User's token (private) Responses format Data format: application/json (http://www.json.org) Charset: UTF-8 Resources Each call on an endpoint will return resources. The main resources are: | Resource | Description | | ---------------------|:------------------------------------------------------------------------------------------------------------------ | |Users |Represent a user | |Connection |A set of data used to authenticate on a website (usually a login and password). There is 1 connection for each website| |Account |A bank account contained in a connection | |Transaction |An entry in a bank account | |Investment |An asset in a bank account | The chain of resources is as follow: Users ∈ Connections ∈ Accounts ∈ Transactions or Investments RESTful API This API is RESTful, which means it is stateless and each resource is accessed with an unique URI. Several HTTP methods are available: | Method | Description | | ------------------------|:-------------------------------| | GET /resources | List resources | | GET /resources/{ID} | Get a resource from its ID | | POST /resources | Create a new resource | | POST /resources/{ID} | Update a resource | | PUT /resources /{ID} | Update a resource | | DELETE /resources | Remove every resources | | DELETE /resources/{ID} | Delete a resource | Each resource can contain sub-resources, for example: /users/me/connections/2/accounts/23/transactions/48 HTTP response codes | Code | Message | Description | | ----------- |:---------------------:|-----------------------------------------------------------------------------------------------| | 200 | OK |Default response when a GET or POST request has succeed | | 202 | Accepted |For a new connection this code means it is necessary to provide complementary information (2FA)| | 204 | No content |Default response when a POST request succeed without content | | 400 | Bad request |Supplied parameters are incorrect | | 403 | Forbidden |Invalid token | | 500 | Internal Servor Error |Server error | | 503 | Service Unavailable |Service is temporarily unavailable | Errors management In case an error occurs (code 4xx or 5xx), the response can contain a JSON object describing this error: If an error is displayed on the website, Its content is returned in error_message field. The list of all possible errors is listed further down this page. Authentication A user is authenticated by an access_token which is sent by the API during a call on one of the authentication services, and can be supplied with this header: Authorization: Bearer YYYYYYYYYYYYYYYYYYYYYYYYYYY There are two user levels: - Normal user, which can only access to his own accounts - Administrator, with extended rights Default filters During a call to an URI which lists resources, some filters can be passed as query parameters: | Parameter | Type | Description | | ----------- |:---------:|-----------------------------------------------------------| | offset | Integer |Offset of the first returned resource | | limit | Integer |Limit number of results | | min_date | Date |Minimal date (if supported by service), format: YYYY-MM-DD | | max_date | Date |Maximal date (if supported by service), format: YYYY-MM-DD | Extend requests During a GET on a set of resources or on a unique resource, it is possible to add a parameter expand to the request to extend relations with other resources: GET /2.0/users/me/accounts/123?expand=transactions[category],connection Request example Constants List of bank account types | Type |Description | | ----------- |-----------------------------------| | checking |Checking account | | savings |Savings account | | deposit |Deposit accounts | | loan |Loan | | market | Market accounts | | joint |Joint account | | card |Card | | lifeinsurance |Life insurance accounts | | pee |Plan Épargne Entreprise | | perco |Plan Épargne Retraite | | article83 |Article 83 | | rsp |Réserve spéciale de participation | | pea |Plan d'épargne en actions | | capitalisation|Contrat de capitalisation | | perp |Plan d'épargne retraite populaire | | madelin |Contrat retraite Madelin | | unknown |Inconnu | List of transaction types | Type |Description | | ----------- |-----------------------------------| |transfer |Transfers | |order |Orders | |check |Checks | |deposit |Cash deposit | |payback |Payback | |withdrawal |Withdrawal | |loan_payment |Loan payment | |bank |Bank fees | |card |Card operation | |deferred_card |Deferred card operation | |card_summary |Mensual debit of a deferred card | List of synchronization errors Error on Connection object The error field may take one of the below values in case of error when accessing the user space. | Error |Description | | ----------------------- |--------------------------------------------------------------------------------------------------| |wrongpass |The authentication on website has failed | |additionalInformationNeeded |Additional information is needed such as an OTP | |websiteUnavailable |The website is unavailable, for instance we get a HTTP 503 response when requesting the website | |actionNeeded |An action is needed on the website by the user, scraping is blocked | |SCARequired |An SCA process must be done by updating the connection | |decoupled |Requires a user validation (ex: digital key)| |passwordExpired |The password has expired and needs to be changed on the website. | |webauthRequired |A complete authentication process is required by update the connection via redirect | |bug |A bug has occurred during the synchronization. An alert has been sent to Budget Insight | Error on Account object Errors can be filled at the account level in case we access the user's dashboard but some account related data cannot be retrieved. For instance, we may not access the transactions or investments for a specific account. Getting an error during an account synchronization does not impact the scraping of other acccounts. | Error |Description | | ----------------------- |--------------------------------------------------------------------------------------------------| |websiteUnavailable |The website or a page is unavailable | |actionNeeded |An action is needed on the website by the user, scraping is blocked | |bug |A bug has occurred during the synchronization. An alert has been sent to Budget Insight | Now you know the basics of Budgea API - Basic call to retrieve resources - Add query parameters to aplly filters - Expand resources - Authenticated calls We're good for the basics! Now let's see how to integrate Budgea in your app and create your first user. Integrate Budgea (protocol or Webview) The workflow Users of your application exist in the Budgea API. Every User is identified by an access_token which is the shared secret between your application and our API. The workflow is as below: 1. The user is on your application and wants to share his bank accounts or invoices. 2. A call is made client side (browser's javascript or desktop application) to create a temporarily token which will be used to make API calls. 3. A form is built, allowing the user to select the connector to use (bank or provider, depending on context). Every connector requires different kind of credentials. 4. A call on the API is made with the temporarily token to add a Connection with the credentials supplied by user. 5. In case of success, the user chooses what bank accounts (Account) or subscriptions (Subscription) he wants to share with your application. 6. When he validates the share, the temporarily token is transmitted to your server. This one will call the Budgea API with this token to get a permanent token. Note In case your application works without a server (for example a desktop application), the permanent token can be obtained on the 1st step, by supplying a client_secret to /auth/init and the step 6 is omitted. To get more information, read the protocol. There are 3 steps to integrate Budgea in your application: 1. Provide a way for your users to share their credentials with you 2. Get the data scraped from Budgea 3. Be sure to follow the good practices before going into production Get credentials from users You have 2 options here: - Integrate the Budget Insight's Webview, a turnkey solution to get user's credentials - Create your own form following the protocol (must have the agent status) Budgea webview The Budgea webview complements REST API endpoints with web-based services to handle sensitive or complex operations: - add a connection (to a bank or a provider), or edit/repare access to a connection; - manage connections (add/remove/edit); - edit and validate bank transfers (alpha preview). Usage of the webview is mandatory if you don't hold an Agent status, since you are not allowed to use API endpoints carrying user credentials, and optional otherwise. Implementation guidelines Base URL The base URL of all services must be customized: https://{{domain}}.biapi.pro/2.0/auth/webview/ https://{{domain}}.biapi.pro/2.0/auth/webview/{{lang}}/ - {{domain}}: substitute with you API domain; - {{lang}}: optionally specify the language of the webview, en or fr (if not specified, an automatic redirection will be performed following the language of the browser). Browser integration Services available as part of the webview are designed as parameterized URLs intended to be opened in a web browser. A callback URI must be specified by callers to be notified at the end of the operation flow, similar to OAuth 2 specification. You are encouraged to integrate web-based steps in your product following UX best practices: - in a web environment, perform a full-page redirect to the URL (using either HTTP redirect or scripting), and avoid new tabs or popups; - in a native Android app, prefer opening the default browser or relying on Chrome Custom Tabs to integrating a WebView; - in a native iOS app, prefer using a SFSafariViewController to integrating a WKWebView. Callback handling Most flows redirect to a callback URI at the end of the process. Query parameters are added to the URI to identify successful or failed operations. Successful parameters are specific to each flow. In case of an error, the following parameters are added: | Parameter | Description | | - | - | | error | An lowercase string error code identifying the kind of error that occurred. When the parameter is not present, the response is successful. | | error_description | A longer string description of the error (not intended for user display). | Common error codes include: | Code | Description | | - | - | | access_denied | The user explicitly cancelled the flow. | | server_error | Oops, a technical failure occurred during the process. | Forward compatibility requirement: Additional error codes may be added in the future to describe specific cases. When implementing error codes handling, always fallback to a generic case for unknown codes. Browser compatibility The webview is designed and tested to work with browsers supported by the Angular framework: https://angular.io/guide/browser-support Privacy / GDPR status The webview itself does not use any kind of long-term data persistence mechanism such as cookies or local storage, but some authentication or authorization steps may delegate to third-party web services that may implement them. Configuration You can configure the appearance and behaviour of the webview by configuring the associated Client Application in the console: | Key | Format | Description | | - | - | - | | primary_color | String | Optional. An accent color (hexadecimal string without '#' prefix) to personalize the UI elements of the webview. If absent, the default color is grey. | | redirect_uri | String | Optional. A recommended security whitelist configuration. The redirect_uri parameter sent to any endpoint of the webview is checked against the configuration, if any. | | config.disable_connector_hints | Boolean | Optional. This flags hides the list of most-used entries in the connector selection step. The default is false, i.e. the list is shown. | | config.use_app_layout | Boolean | Optional. Use this flag to enable presenting your log as an app icon. The default value is false, i.e. the logo is shown in the top bar of the UI. | | config.disable_accounts_pre_check | Boolean | Optional. An optional boolean flag to prevent bank accounts to be automatically pre-checked when the user enters the activation step. The default value is false, i.e. the bank accounts are pre-checked. | Endpoints reference Add connection flow This flow allows an end-user to add a new connection to the API. The flow handles the following steps: - selecting a connector; - authenticating & authorizing with the connector, by collecting credentials or delegating; - managing consent to aggregate accounts/subscriptions; - collecting required information for professional accounts. Endpoint parameters | Parameter | Description | | - | - | | client_id | Required. The ID of the requesting client application. You can manage client applications of your domain in the admin console. | | redirect_uri | Required. An absolute callback URI. The webview will redirect to it at the end of the flow. | | code | Optional. A user-scoped temporary code to use with the Budgea API.If you don't provide a code, a new anonymous user will be created before the connection is added, and you will be returned an access token code scoped to it with the success callback. | | state | Optional. An opaque string parameter that you can use to carry state across the flow. The parameter will be set \"as is\" on the callback URI. Make sure that the state you provide is properly URL-encoded. | | connector_ids | Optional. A comma-separated list of connector IDs available to pick from.If the parameter is omitted, all active connectors are available.If you pass a single value, the user is not prompted to choose the connector.This parameter is mutually exclusive with connector_uuids. | | connector_uuids | Optional. A comma-separated list of connector UUIDs available to pick from.If the parameter is omitted, all active connectors are available.If you pass a single value, the user is not prompted to choose the connector.This parameter is mutually exclusive with connector_ids. | | connector_capabilities | Optional. A comma-separated list of capabilities to filter available connectors.If the parameter is omitted, bank is inferred.If multiple values are provided, only connectors that expose all the requested capabilities are available.To request a bank connection, use bank.To request a provider connection, use document. | | account_ibans | Optional. A comma-separated list of IBANs to filter accounts available for activation in a bank connection context. Other accounts will not be selectable. | | account_types | Optional. A comma-separated list of account types to filter accounts available for activation in a bank connection context. Other accounts will not be selectable. | | account_usages | Optional. A comma-separated list of account usages to filter accounts available for activation in a bank connection context. Other accounts will not be selectable. | Successful callback parameters | Parameter | Description | | - | - | | connection_id | The id of the newly created connection. Please note that when redirecting to the callback URI, the accounts and/or subscriptions are available in the API, but bank transactions or documents may still be syncing in background. | | code | Optional. If a code was not initially specified, an API code that you must exchange to obtain a permanent access token associated with the newly-created anonymous user holding the connection. The parameter is URL-encoded, make sure to handle it accordingly. | | state | Optional. Identical to the state parameter that was initially specified. | Additional error codes | Code | Description | | - | - | | tos_declined | The end-user refused to validate the terms of service. | Re-auth / edit connection credentials flow This flow allows an end-user to re-authenticate against a bank or a provider in order to recover an existing connection, or to completely reset credentials associated with a connection. Endpoint parameters | Parameter | Description | | - | - | | client_id | Required. The ID of the requesting client application. You can manage client applications of your domain in the admin console. | | redirect_uri | Required. An absolute callback URI. The webview will redirect to it at the end of the flow. | | code | Required. A user-scoped temporary code to use with the Budgea API. | | connection_id | Required. The id of the existing connection. | | state | Optional. An opaque string parameter that you can use to carry state across the flow. The parameter will be set \"as is\" on the callback URI. Make sure that the state you provide is properly URL-encoded. | | reset_credentials | Optional. In the default mode (false), the service will try to recover the connection and prompt the user only with outdated or transient information (new password, OTP...).Set the parameter to true to force resetting all the credentials associated with the connection. This parameter may not apply to all connectors. | Successful callback parameters This flow adds no parameter to the callback URI in case of success, except from state. Manage connections This flow allows an end-user to manage the connections associated with his account in the API. The user can add new connections, remove existing ones, fix connection errors, reset credentials or activate/deactivate bank accounts. Support of redirect_uri in this flow is optional, as it can be integrated or presented as a terminal step, without relying on a final redirection. Endpoint parameters | Parameter | Description | | - | - | | client_id | Required. The ID of the requesting client application. You can manage client applications of your domain in the admin console. | | code | Required. A user-scoped temporary code to use with the Budgea API. | | redirect_uri | Optional. An absolute callback URI. When provided, the webview will display a close button that redirects to it. | | state | Optional. An opaque string parameter that you can use to carry state across the flow when providing a redirect_uri. The parameter will be set \"as is\" on the callback URI. Make sure that the state you provide is properly URL-encoded. | | connector_capabilities | Optional. A comma-separated list of capabilities to filter available connectors when adding a new connection.If the parameter is omitted, bank is inferred.If multiple values are provided, only connectors that expose all the requested capabilities are available.To request a bank connection, use bank.To request a provider connection, use document. | | account_types | Optional. A comma-separated list of account types to filter accounts available for activation on adding a new bank connection or updating existing connections. Other accounts will not be selectable. | | account_usages | Optional. A comma-separated list of account usages to filter accounts available for activation in a bank connection context. Other accounts will not be selectable. | Callback parameters This flow adds no parameter to the callback URI, except from state. Execute a bank transfer (preview) Disclaimer: Transfer or payment services are available as a preview, protocols and parameters are subject to change in upcoming beta/final releases. This flow allows an end-user to execute a bank transfer. The flow handles the following steps: - if the transfer is not already created, all steps to authenticate with a bank, select the recipient, the emitter account, the amount and label; - executing the transfer, including managing SCAs for recipient registration and/or transfer validation. Endpoint parameters | Parameter | Description | | - | - | | client_id | Required. The ID of the requesting client application. You can manage client applications of your domain in the admin console. | | redirect_uri | Required. An absolute callback URI. The webview will redirect to it at the end of the flow. | | code | Required. A user-scoped temporary code to use with the Budgea API.If you don't provide a code, a new anonymous user will be created before a connection is added and the transfer is executed, and you will be returned an access token code scoped to it with the success callback. | | state | Optional. An opaque string parameter that you can use to carry state across the flow. The parameter will be set \"as is\" on the callback URI. Make sure that the state you provide is properly URL-encoded. | | transfer_id| Optional. The ID of an prepared transfer to be validated in the webview. The user cannot edit anything on the transfer before validation. | Successfull callback parameters | Parameter | Description | | - | - | | transfer_id | The ID of the transfer that was created and executed. | | code | Optional. If a code was not initially specified, an API code that you can exchange to obtain a permanent access token associated with the newly-created anonymous user holding the transfer. The parameter is URL-encoded, make sure to handle it accordingly. | | state | Optional. Identical to the state parameter that was initially specified. | Additional error codes | Code | Description | | - | - | | tos_declined | The end-user refused to validate the terms of service. | Migrating from v3 We provide a full backward compatibility layer with current implementations of the webview v3 to ease the transition. All endpoints remains accessible, with the same parameters and callback behaviour. Migration instructions are provided below. The v3 compatibility mode is expected to be removed on 31 December 2019. You should migrate your implementation a soon as possible to new endpoints and parameters. Add connection flow / Edit connection credentials This endpoint has been superseded by /connect (no suffix) for adding a new connection, and /reconnect for resetting or updating an existing connection. | Endpoint parameter | Migration instructions | | - | - | | client_id | No change. | | redirect_uri, state | No change. | | response_type | This parameter is not used anymore. | | id_connector, connectors | Superseded by connector_ids sent to the /connect endpoint. | | types | Superseded by connector_capabilities sent to the /connect endpoint.Useconnector_capabilities=bank (bank connection) or connector_capabilities=document (provider connection). | | id_connection | Superseded by connection_id sent to the /reconnect endpoint. | Passing the code or access token as an URL fragment is no longer supported, use the code query parameter. | Callback parameter | Migration instructions | | - | - | | id_connection | Superseded by connection_id.In the /reconnect flow, this parameter is not returned anymore. | | code | Still named code, but in the /connect flow the parameter is now only added if an anonymous user was created, i.e. the code parameter was not provided as a query parameter or fragment.In the /reconnect flow, this parameter is not returned anymore. | | state | No change. | Manage connections This endpoint has been superseded by /manage, that now fully allows users to add/remove connections, reset their credentials or recover from error states. | Endpoint parameter | Migration instructions | | - | - | | client_id | No change. | | redirect_uri, state | No change, these parameters are now optional. | | response_type | This parameter is not used anymore. | | types | Superseded by connector_capabilities.Useconnector_capabilities=bank (bank connection) or connector_capabilities=document (provider connection). | Passing the code or access token as an URL fragment is no longer supported, use the code query parameter. | Callback parameter | Migration instructions | | - | - | | code | This parameter is not returned anymore. | | state | No change. | Behaviour change In v3, the /accounts flow used to redirect to the redirect_uri after a connection addition. This is no longer the case in v4, where redirection is only performed when the user explicitly closes the flow. If you need to perform actions when a connection is added or removed, you should rely on webhooks. Protocol This section describes the protocol used to set bank and provider accounts of a user, in case you don't want to use the webview. The idea is to call the following services client-side (with AJAX in case of a web application), to ensure the bank and providers credentials will not be sent to your servers. 1. /auth/init This service creates a temporarily token, to use in the \"Authorization\" header in next calls to the API The returned token has a life-time of 30 minutes, and should be transfered to the API then (cf Permanent Token), so that your server can get a permanent access_token. It is possible to generate a permanent token immediately, by calling the service with the manage_token, or by supply parameters client_id and client_secret. 2. /banks or /providers You get a list of connectors, and all associated fields needed to build the form at step 3. You can also use that list to show to your user, all available banks. 3. /users/me/connections Make a POST request and supply the id_bank (ID of the chosen bank) or id_provider (ID of provider), and all requested fields as key/value parameters. For example: You can get the following return codes: |Code |Description | |---------------|------------------------------------------------------------ | |200 |The connection has succeed and has been created | |202 |It is necessary to provide complementary information. This occurs on the first connection on some kind of Boursorama accounts for example, where a SMS is sent to the customer. It is necessary to ask the user to fill fields requested in the fields, and do a POST again on /users/me/connections/ID, with the connection ID in id_connection. | |400 |Unable to connect to the website, the field error in the JSON can be websiteUnavailable or wrongpass | |403 |Invalid token | 4. Activate accounts The accounts the user wants to aggregate must be activated before any transaction or investment is retrieved. Several accounts can be activated in 1 request by separating the account ids with commas. 5. Permanent token If the user validates the share of his accounts, it is necessary to transform the temporary code to a permanent access_token (so that the user won't expire). To do that, make a POST request on /auth/token/access with the following parameters: |Parameter |Description | |---------------------|----------------------------------------------------------------| |code |The temporarily token which will let you get the access_token | |client_id |The ID of your client application | |client_secret |The secret of your client application | Update accounts Another important call is when a user wants to add/remove connections to banks or providers, or to change the password on one of them, it is advised to give him a temporarily code from the permanent access_token, with the following call (using the access_token as bearer): Its life-time is 30 minutes, and let the browser to list connections and accounts, via GET /users/me/connections?expand=accounts for example. To update the password of a connection, you can do a POST on the connection resource, with the field password in the data. The new credentials are checked to make sure they are valid, and the return codes are the same as when adding a connection. Getting the data (Webhooks) You have created your users and their connections, now it's time to get the data. There are 2 ways to retrieve it, the 2 can be complementary: - make regular calls to the API - use the webhooks (recommended) Manual Synchronization It is possible to do a manual synchronization of a user. We recommend to use this method in case the user wants fresh data after logging in. To trigger the synchronization, call the API as below: PUT /users/ID/connections The following call is blocking until the synchronization is terminated. Even if it is not recommended, it's possible to fetch synchronously new data. To do that, you can use the expand parameter: /users/ID/connections?expand=accounts[transactions,investments[type]],subscriptions Background synchronizations & Webhooks Webhooks are callbacks sent to your server, when an event is triggered during a synchronization. Synchronizations are automatic, the frequency can be set using the configuration key autosync.frequency. Using webhooks allows you to get the most up-to-date data of your users, after each synchronization. The automatic synchronization makes it possible to recover new bank entries, or new invoices, at a given frequency. You have the possibility to add webhooks on several events, and choose to receive each one on a distinct URL. To see the list of available webhooks you can call the endpoint hereunder: The background synchronizations for each user are independent, and their plannings are spread over the day so that they do not overload any website. Once the synchronization of a user is over, a POST request is sent on the callback URL you have defined, including all webhook data. A typical json sent to your server is as below: The authentication on the callback is made with the access_token of the user (which is a shared secret between your server and the Budgea API). When you are in production, it is needed to define a HTTPS URL using a valid certificate, delivered by a recognized authority. If this is not the case, you can contact us to add your CA (Certificate Authority) to our PKI (Public Key Infrastructure). Important: it is necessary to send back a HTTP 200 code, without what we consider that data is not correctly taken into account on your system, and it will be sent again at the next user synchronization. Guidelines for production Now you should have integrated the API inside your application. Make sure your Webhooks URLs are in HTTPS, if so you can enable the production state of the API. To make things great, here are some good practices, please check you have respected them: - You have provided to your users a way to configure their accounts - You have provided to your users a way to change their account passwords - You consider the error field of Connections, to alert the user in case the state is wrongpass - You map IDs of Accounts, Subscriptions, Transactions and Documents in your application, to be sure to correctly match them - When the deleted field is set on a bank transaction, you delete it in your database - You don't loop on all users to launch synchronizations, this might saturate the service If you have questions about above points, please contact us. Otherwise, you can put into production! Going further If you want to raise the bar for your app and add features such as the ability to do transfers, get invoices, aggregate patrimony and more, please refer to the sections below. We'll discuss complementary APIs building upon the aggregation, allowing for the best of financial apps. Budgea API Pay This API allows for the emition of transfers between the aggregated accounts. Just like the simple aggregation, BI provides a webview or a protocol to follow, to implement this feature. API pay protocol This section describes how the transfer and recipient protocol work, in case you don't want to integrate the webview. The idea is to do following calls client side (with AJAX in case of a web application), so that the interaction with the Budgea API is transparent. Executing a transfer 1. /auth/token/code If you do calls client side, get a new temporary code for the user, from the access_token. This will prevent security issues. The returned token has a life-time of 30 minutes. 2. /users/me/accounts?able_to_transfer=1 List all the accounts that can do transfers. Authenticate the call with the code you got at step 1. 3. /users/me/accounts/ID/recipients List all available recipients for a given account. 4. /users/me/accounts/ID/recipients/ID/transfers Create the transfer 5. /users/me/transfers/ID Execute the transfer Here, an authentication step asks user to enter his bank password. The transfer can be validated with: The field state is changed to pending, telling that the transfer has been correctly executed on the bank. A connection synchronization is then launched, to find the bank transaction in the movements history. In this case, the transfer state will be changed to done. Adding a recipient 1. /auth/token/code Get a temporary token for the user. Same procedure than step 1 for a transfer. 2. /users/me/accounts?able_to_transfer=1 List accounts allowing transfers. Same procedure than step 2 for a transfer. 3. /users/me/accounts/ID/recipients/ Add a new recipient. It is necessary to post on the object Recipient with the requested fields (here sms), until the add is validated: If the field enabled_at is in the future, it means that it isn't possible yet to execute a transfer, as the bank requires to wait a validation period. API Pay Webview This section describes how to integrate the webview of the Budgea Pay API inside your application, to let your users do transfers to their recipients. User redirection To redirect the user to the webview, it is necessary to build a URI authenticated with a temporary token. This can be done from our library, or by calling the endpoint /auth/token/code (see the protocol section for an example). If the parameter redirect_uri is supplied, the user will be redirected to that page once the transfer is done. List of pages Here are a list a pages you may call to redirect your user directly on a page of the process: |Path |Description of the page | |-------------------------------------|----------------------------------------------------------------------------------| |/transfers |List Transfers | |/transfers/accounts |List emitter accounts | |/transfers/accounts/id/recipients |List recipients | |/transfers/accounts/id/recipients/id |Initialization of a transfer between the account and the recipient | |/transfers/id |Detail of a given transfer | Deprecated This section lists all the deprecated features in Budgea API. The associated date is the date of its removal. Do not use them. Key Investments (2019-06-24) Adding a temporary new key \"all_investments\" that will include deleted investments in the webhooks. No automatic expand on User objects (2019-07-30) In the API responses, by default, User objects won't display the keys \"config\", \"alert_settings\" and \"invites\" anymore. You will still be able to access this data by expanding the request. Example: GET /users/me/?expand=alert_settings,config Renaming of \"type\" field for jwt tokens (2019-07-30) For user's tokens in the jwt format, the \"type\" field will be renamed from \"shared_access\" to \"sharedAccess\".",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "biapi.pro",
      "documentation_url": "https://biapi.pro",
      "version": "2.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Budgea API Documentation",
      "paths_count": 110,
      "schemas_count": 56
    }
  },
  {
    "name": "1_000_000_recipe_and_grocery_list_api_v2",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/bigoven.com/partner/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Documentation This is the documentation for the partner endpoint of the BigOven Recipe and Grocery List API. The update brings with it Swagger-based documentation. Swagger is an emerging standard for describing REST-based APIs, and with this Swagger-compliant endpoint (above), you can make ready-to-go interface libraries for your code via swagger-codegen. For instance, it's easy to generate libraries for Node.js, Java, Ruby, ASP.NET MVC, jQuery, php and more! You can also try out the endpoint calls with your own api_key right here on this page. Be sure to enter your api_key above to use the \"Try it out!\" buttons on this page. Start Here Developers new to the BigOven API should start with this version, not with the legacy API. We'll be making improvements to this API over time, and doing only bug fixes on the v1 API. To pretend you're a BigOven user (for instance, to get your recently viewed recipes or your grocery list), you need to pass in Basic Authentication information in the header, just as with the v1 API. We do now require that you make all calls via https. You need to pass your api_key in with every call, though this can now be done on the header (send a request header \"X-BigOven-API-Key\" set to your api_key value, e.g., Request[\"X-BigOven-API-Key\"]=\"your-key-here\".) Migration Notes For existing partners, we encourage you to migrate, and while at this writing we have no hard-and-fast termination date for the v1 API, we strongly prefer that you migrate by January 1, 2017. While the changes aren't overly complex, there are several breaking changes, including refactoring of recipe search and results and removal of support for XML. This is not a simply plug-and-play replacement to the v1 API. With respect to an exclusive focus on JSON, the world has spoken, and it prefers JSON for REST-based API's. We've taken numerous steps to refactor the API to make it more REST-compliant. Note that this v2 API will be the preferred API from this point onward, so we encourage developers to migrate to this new format. We have put together some migration notes that we encourage you to read carefully. Photos See our photos documentation. For more information on usage of this API, including features, pricing, rate limits, terms and conditions, please visit the BigOven API website.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "bigoven.com",
      "documentation_url": "http://api2.bigoven.com/web/documentation",
      "version": "partner",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "1,000,000+ Recipe and Grocery List API (v2)",
      "paths_count": 53,
      "schemas_count": 56
    }
  },
  {
    "name": "big_red_cloud_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/bigredcloud.com/v1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Welcome to the Big Red Cloud API This API enables programmatic access to Big Red Cloud data. We have used Swagger to auto generate the API documentation on this page, and it also enables direct interaction with the API in this page. To get started, you will require an API Key - check out our guide at https://www.bigredcloud.com/support/generating-api-key-guide/ for information on how to get one. Use the 'Enter API Key' button below to enter your API key and start interacting with your Big Red Cloud data right on this page. The API key will be stored in your browsers local storage for convenience, but you will be able to delete it at any time if you wish. For additional information on the API, check out our support article at https://www.bigredcloud.com/support/api/",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "bigredcloud.com",
      "documentation_url": "https://bigredcloud.com",
      "version": "v1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Big Red Cloud API",
      "paths_count": 72,
      "schemas_count": 152
    }
  },
  {
    "name": "billbee_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/billbee.io/v1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Documentation of the Billbee REST API to connect a Billbee account to external aplications. Endpoint The Billbee API endpoint base url is https://api.billbee.io/api/v1 Activation You have to enable the API in the settings of your Billbee account. In addition you need a Billbee API Key identifying the application you develop. To get an API key, send a mail to support@billbee.io and send us a short note about what you are building. Authorization & security Because you can access private data with the Billbee API, every request has to be sent over https and must * Contain a valid API Key identifying the application/developer. It has to be sent as the HTTP header X-Billbee-Api-Key * Contain a valid user login with billbee username and api password in form of a basic auth HTTP header Throttling Each endpoint has a throttle of max 2 requests per second per combination of API Key and Billbee user. When you exceed these 2 calls, the API will return a HTTP 429 status code",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Billbee GmbH",
      "documentation_url": "https://www.billbee.io",
      "version": "v1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Billbee API",
      "paths_count": 55,
      "schemas_count": 94
    }
  },
  {
    "name": "billingo_api_v3",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/billingo.hu/3.0.7/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is a Billingo API v3 documentation. Our API based on REST software architectural style. API has resource-oriented URLs, accepts JSON-encoded request bodies and returns JSON-encoded responses. To use this API you have to generate a new API key on our site. After that, you can test your API key on this page.",
      "category": "Finance & Payments",
      "last_updated": "2025-08-03",
      "maintainer": "Billingo Support",
      "documentation_url": "https://support.billingo.hu/content/446136358",
      "version": "3.0.7",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Billingo API v3",
      "paths_count": 19,
      "schemas_count": 47
    }
  },
  {
    "name": "bitbucket_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/bitbucket.org/2.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Code against the Bitbucket API to automate simple tasks, embed Bitbucket data into your own site, build mobile or desktop apps, or even add custom UI add-ons into Bitbucket itself using the Connect framework.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Bitbucket Support",
      "documentation_url": "https://bitbucket.org/api",
      "version": "2.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Bitbucket API",
      "paths_count": 178,
      "schemas_count": 197
    }
  },
  {
    "name": "box_platform_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/box.com/2.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Box Platform provides functionality to provide access to content stored within Box. It provides endpoints for basic manipulation of files and folders, management of users within an enterprise, as well as more complex topics such as legal holds and retention policies.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Box, Inc",
      "documentation_url": "https://developer.box.com",
      "version": "2.0.0",
      "openapi_version": "3.0.2",
      "quality_score": 100,
      "is_popular": false,
      "title": "Box Platform API",
      "paths_count": 161,
      "schemas_count": 179
    }
  },
  {
    "name": "rocket_services",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/britbox.co.uk/3.730.300-ref-1-39-0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "An Orchestration Layer that takes ISL services and packages them in a more targeted way for front-end applications. This in turn makes client integration easier and reduces the complexity and size of front-end applications. Rocket is also customisable - allowing UI engineers to ‘remix’ the existing back-end services into something that best suits the application they are developing.",
      "category": "General",
      "last_updated": "2025-08-03",
      "maintainer": "britbox.co.uk",
      "documentation_url": "https://britbox.co.uk",
      "version": "3.730.300-ref-1-39-0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Rocket Services",
      "paths_count": 100,
      "schemas_count": 153
    }
  },
  {
    "name": "bungie_net_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/bungie.net/2.18.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "These endpoints constitute the functionality exposed by Bungie.net, both for more traditional website functionality and for connectivity to Bungie video games and their related functionality.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Bungie.net API Support",
      "documentation_url": "https://github.com/Bungie-net/api/wiki/OAuth-Documentation",
      "version": "2.18.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Bungie.Net API",
      "paths_count": 134,
      "schemas_count": 869
    }
  },
  {
    "name": "bunq_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/bunq.com/1.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "UPDATE: We have released a beta version of the new bunq API documentation. NOTICE: We have updated the sandbox base url to https://public-api.sandbox.bunq.com/v1/. Please update your applications accordingly. Check here: for more info. PSD2 NOTICE: The second Payment Services Directive (PSD2) may affect your current or planned usage of our public API, as some of the API services are now subject to a permit. Please be aware that using our public API without the required PSD2 permit is at your own risk and take notice of our updated API Terms and Conditions on for more information. Introduction Welcome to bunq! - The bunq API is organised around REST. JSON will be returned in almost all responses from the API, including errors but excluding binary (image) files. - Please configure your implementation to send its API requests to https://public-api.sandbox.bunq.com/v1/ - There is a version of the Android app that connects to the bunq Sandbox environment. To create accounts for the Sandbox app, please follow the steps in the Android Emulator section. Getting started Before you start sending API requests, you need to get an API key and activate it. API activation happens when you install the API key and link your IP address and device to it (create an API context). The steps below will guide you through what you need to do to start sending custom API requests. Here is an overview of what you can use to get started with the bunq API: 1. Create an API key. You can do it either in our developer portal or in the bunq app (Profile → Security & Settings → Developers → API keys). If you want to test our sandbox first, our bunq Developer is the best place to start. 2. Register a device. A device can be a phone (private), computer or a server (public). You can register a new device by using the POST /installation and POST /device-server calls. This will activate your API key. You only need to do this once. 3. Open a session. Sessions are temporary and expire after the auto-logout time set for the user account. It can be changed by the account owner in the bunq app. 4. Make your first call! !bunq_API_context Versioning Developments in the financial sector, changing regulatory regimes and new feature requests require us to be flexible. This means we can iterate quickly to improve the API and related tooling. Therefore, we have chosen not to attach any version numbers to the changes just yet. We will inform you in a timely manner of any important changes we make before they are deployed on together.bunq.com. You can also subscribe to our API newsletter to make sure you don't miss any important updates. OAuth What is OAuth? OAuth 2.0 is a protocol that will let your app connect to bunq users in a safe and easy way. Please be aware that if you will gain access to the account information of other bunq users or initiate a payment for them, you may require a PSD2 permit. Get started with OAuth for bunq To initiate authorization into the bunq user accounts, you need to create an OAuth Client and register at least 1 redirect URL for it. You can have 1 OAuth Client at a time. Reuse your OAuth credentials for every authorization request. The list of steps below will help you to get started: 1. Register an OAuth Client by creating an app in bunq Developer_._ 2. Add one or more Redirect URLs. 3. Get your client_id and secret from your app information tab in bunq Developer. 4. Redirect your users to the OAuth authorization request URL. 5. If the user accepts the authorization request, they will be redirected to the previously specified redirect_uri with an authorization code parameter. 6. Use the token endpoint to exchange the authorization code for an access_token. 7. Use the access_token as a normal API Key. Open a session or use our SDKs to get started. You can set up an OAuth Client and add redirect URLs to it using the dedicated endpoints too. Follow the flow below to do it programmatically. ℹ️ As a PSD2 user, you cannot log in to the bunq app. You need to follow the flow below to register an OAuth Client for your application. !bunq_OAuth_credentials What can my apps do with OAuth? We decided to launch OAuth with a default permission that allows you to perform the following actions: - read and create Monetary Accounts; - read Payments & Transactions; - create Payments between Monetary Accounts of the same user; - create Draft-Payments (the user will need to approve the payment using the bunq app); - assign a Monetary account to a Card; - read, create and manage Cards; - read and create Request-Inquiries - read Request-Responses. As a PSD2-licensed developer, you are limited to the permission scopes of your role. Authorization request Your web or mobile app should redirect users to the following URL: https://oauth.bunq.com/auth The following parameters should be passed: - response_type - bunq supports the authorization code grant, provide code as parameter (required) - client_id - your Client ID, get it from the bunq app (required) - redirect_uri - the URL you wish the user to be redirected after the authorization, make sure you register the Redirect URL in the bunq app (required) - state - a unique string to be passed back upon completion (optional) Use https://oauth.sandbox.bunq.com/auth in the sandbox environment. Authorization request example: Authorization request response: !bunq_OAuth_authorization_token_exchange.jpg Token exchange If the authorization request is accepted by the user, you get the authorization code_._ Exchange it for an access_token. Make a POST call to https://api.oauth.bunq.com/v1/token . Pass the following parameters as GET variables: - grant_type - the grant type used, authorization_code for now (required) - code - the authorization code received from bunq (required) - redirect_uri - the same Redirect URL used in the authorisation request (required) - client_id - your Client ID (required) - client_secret - your Client Secret (required) Use https://api-oauth.sandbox.bunq.com/v1/token in the sandbox environment. Token request example: Note: The request should only contain URL parameters. No body is expected. Example successful response: Example error response: What's next? To start sending calls to the account of the user who has accepted your authorization request, create an API context for the access_token you have received as the result of the token exchange. The access_token can be used as a normal API key. Please continue with Authentication. NOTE: When connecting to a bunq user's account using OAuth, you create a new user \\(userApiKey\\) that has its own id and access_token . When sending a request on behalf of a user connected to your app via OAuth, use the id of userApiKey as userId and the item ids of the bunq user \\(grantedByUser\\). Example of a successful request URL: When calling GET /user/{userID}, you might expect to get UserPerson or UserCompany. Instead, you will get the UserApiKey object, which contains references to both the user that requested access (you) and the user that granted access (the bunq user account that you connected to). !bunq_OAuth UserApiKey.jpg?alt=media&token=d1f212a2-3105-4f0e-a980-34b04a12998a) Using the Connect button All good? Ready to connect to your bunq users? Refer to our style guide and use the following assets when implementing the Connect to bunq button. - Style guide - Connect button assets Visit us on together.bunq.com, share your creations, ask question and build your very own bunq app! Authentication - All requests must use HTTPS. HTTP calls will fail. - You should use SSL Certificate Pinning and Hostname Verification to ensure your connection with bunq is secure. - The auto logout time that you set in the app applies to all your sessions including the API ones. If a request is made 30 minutes before a session expires, the session will automatically be extended. - We use extra signing on top of HTTPS encryption that you must implement yourself if you are not using the SDKs. ℹ️ We use asymmetric cryptography for signing requests and encryption. - The client (you) and the server (bunq) must have a pair of keys: a private key and a public key. You need to pre-generate your own pair of 2048-bit RSA keys in the PEM format aligned with the PKCS #8 standard. - The parties (you and bunq) exchange their public keys in the first step of the API context creation flow. All the following requests must be signed by both your application and the server. Pass your signature in the X-Bunq-Client-Signature header, and the server will return its signature in the X-Bunq-Server-Signature header. Device registration Before you can start calling the bunq API, you must activate your API key, which covers the following steps: * register your API key, device, and IP address\\(es\\) _\\(only once to activate your API key\\);_ * create a session via POST /session-server. We call this sequence of steps \"creating an API context.\" If you are using OAuth to access a user account, you need to create an API context for the access_token you receive upon authorization token exchange too. Using our SDKs 1. Go to our GitHub page. 2. Choose the SDK in your language of choice. 3. Find and use the part dedicated to creating an API context. Run Tinker to see a sample project using bunq SDKs in action. Using our API directly 1. Create an _Installation_ by calling POST v1/installation and passing your pre-generated public key. You will receive an installation _Token._ Use it when making the two following API calls. 2. Create a _DeviceServer_ via POST v1/device-server. Provide a description and a secret \\(API key in this case\\). 3. Create a _SessionServer_ by executing POST v1/session-server. You will receive an authentication _Token._ Use it in the API requests in this active session.​ Import our Postman collection to see our pre-setup API context creation calls. It will automatically generate and pre-fill everything in the API calls that create context so you can inspect the process. IP addresses When using a standard API Key the DeviceServer and Installation that are created in this process are bound to the IP address they are created from. Afterwards it is only possible to add IP addresses via the Permitted IP endpoint. Using a Wildcard API Key gives you the freedom to make API calls from any IP address after the POST device-server. You can switch to a Wildcard API Key by tapping on “Allow All IP Addresses” in your API Key menu inside the bunq app. You can also programatically switch to a Wildcard API Key by passing your current ip and a ` (asterisk) in the permitted_ips field of the device-server POST call. E.g: [\"1.2.3.4\", \"\"]. Connect as a PSD2 service provider As a service provider, either an Account Information Service Provider (AISP), Payment Initiation Service Provider (PISP), or Card Based Payment Instrument Issuer (CBPII), you have obtained or are planning to obtain a license from your local supervisor. You will need your unique eIDAS certificate number to start using the PSD2-compliant bunq API on production. We accept pseudo certificates in the sandbox environment so you could test the flow. You can generate a test certificate using the command below. ⚠️ Make sure to include AISP and/or PISP in the name to generate a certificate with the roles. Register as a service provider Before you can read the information on bunq users or initiate payments, you need to register a PSD2 account and receive credentials that will enable you to access the bunq user accounts. 1. Execute POST v1/installation and get your installation Token with a unique random key pair. 1. Use the installation Token and your unique PSD2 certificate to call POST v1/payment-service-provider-credential. This will register your software. 1. Receive your API key in return. It will identify you as a PSD2 bunq API user. You will use it to start an OAuth flow. The session will last 90 days. After it closes, start a new session using the same API key. 1. Register a device by using POST v1/device-server using the API key for the secret and passing the installation Token in the X-Bunq-Client-Authentication header. 1. Create your first session by executing POST v1/session-server. Provide the installation Token in the X-Bunq-Client-Authentication header. You will receive a session Token. Use it in any following request in the X-Bunq-Client-Authentication header. NOTE. The first session will last 1 hour. Start a new session within 60 minutes. !bunq_PSD2_API_context Register your OAuth application Before you can start authenticating on behalf of a bunq user, you need to get Client ID and Client Secret, which will identify you in authorization requests to the user accounts. 1. Call POST /v1/user/{userID}/oauth-client to create an OAuth Client. 2. Add a redirect URL to the OAuth Client via POST /user/{userID}/oauth-client/{oauth-clientID}/callback-url. 3. Call GET /v1/user/{userID}/oauth-client/{oauth-clientID}. We will return your _Client ID_ and _Client Secret_. 4. You are ready to initiate authorization requests. The flow below will guide you through the full OAuth connection process. Note that you only need to create OAuth credentials once. !bunq_full_OAuth_flow Access user accounts as an AISP As an AISP, you are allowed to authenticate in a user’s account and access \\(read\\) the following account information: 1. legal name 2. IBAN 3. nationality 4. card validity data 5. transaction history 6. account balance To read the user's information, you need to establish a connection with their bunq account. You can do it using an authorization request. Once a bunq user has confirmed the authorization request and you have done the token exchange, you can activate the Access Token \\(use it as an API key\\). Token activation happens when you create an API context \\(install it and link your IP adrress and device to it\\). See the OAuth page for the full flow illustration. An active Access Token allows you to communicate with the bunq user’s account. You can use it to start a session to interact with the monetary accounts the user allows you to access. !bunq_AISP Make payments as a PISP As a PISP, you are allowed to authenticate in a user’s account with the following permissions: read account information \\(viaGET /user\\): * legal name; * IBAN; 2. initiate payments \\(create draft payments via either POST /user/{userID}/monetary-account/{monetary-accountID}/draft-payment or POST /user/{userID}/payment-service-provider-draft-payment\\) and read their statuses; 3. confirm that the account balance is sufficient for covering the payment \\(viaPOST /user/{userID}/confirmation-of-funds\\). The bunq API provides endpoints for different scenarios of the implementation of the payment initiation functionality. In particular, as a PISP user, you can build applications that initiate and authorize one-off or multiple incoming payments. Depending on the use case you are intending to deploy, you might need to initiate the OAuth authorization either before or after the payment initiation. Authorization of multiple (scheduled) payments It is possible to initiate payments from a bunq user's account having previously established an OAuth connection between your application and the bunq user's account. The bunq user will receive push notifications for each initiated payment. Once a bunq user has confirmed they want to make payments via your application, you can initiate the payment confirmation flow. 1. Create a draft payment via POST /user/{userID}/monetary-account/{monetary-accountID}/draft-paymentpassing the following parameters: * monetary-accountId and userId (userApiKey's id; see OAuth for more information) in the endpoint URL; * the customer’s email address, phone number, or IBAN in the counterparty_alias field of the request body. 2. If the user confirms their intent to make the payment, bunq carries out the transaction. 3. Check the status of the payment via GET /user/{userID}/monetary-account/{monetary-accountID}/draft-payment using the draft payment id parameter returned in the previous step. !bunq_PISP Single payment authorization It is possible to initiate payments having only the IBAN of the payer using POST /user/{userID}/payment-service-provider-draft-payment. In this case, the bunq user will accept the payment along with the authorization request. No additional push notifications are sent to the user. 1. Collect the bunq user's IBAN (and name) in the UI of your application. 2. Create a draft payment via POST /user/{userID}/payment-service-provider-draft-payment. 3. Initiate an authorization request. Upon the QR-code scan, the bunq user will see and be able to either accept or reject the payment authorization request. 4. Check the status of the payment. !bunq_PISP_single_payment Confirm available funds as a CBPII As a CBPII, you are allowed to authenticate in a user’s account to validate the availability of funds for the payment in question. 1. Collect an alias for the bunq user's account (their name and IBAN, email address, or phone number). 2. Check the availability of funds via POST /user/{userID}/confirmation-of-funds passing the following information: * your userId; * the amount of money needed for the payment; * the name of the bunq user and the IBAN of the account (email address or phone number pointing at the user are also possible). Signing ⚠️ NOTE: We deprecated the signing of the entire API request (the URL, headers and body). You only need to sign the request body. Requests with full request signatures are no longer validated. We are legally required to protect our users and their data from malicious attacks and intrusions. That is why we beyond having a secure https connection, we use asymmetric cryptography for signing requests that create a session or payment. The use of signatures ensures the data is coming from the trusted party and was not modified after sending and before receiving. Request body signing is only mandatory for the following operations: - open a session; - create a payment; - create a scheduled payment; - any other operation that executes a payment such as the following: - accept a draft payment; - accept a scheduled payment; - accept a draft scheduled payment; - accept a payment request. You will know that the API call must be encrypted if you get the 466 error code. The signing mechanism is implemented in our SDKs so if you are using them you don't have to worry about the details described below. The signatures are created using the SHA256 cryptographic hash function and included (encoded in base 64) in the X-Bunq-Client-Signature request header and X-Bunq-Server-Signature response header. The data to sign is the following: - For requests: the body only. - For responses: the body only. For signing requests, the client must use the private key corresponding to the public key that was sent to the server in the installation API call. That public key is what the server will use to verify the signature when it receives the request. In that same call the server will respond with a server side public key, which the client must use to verify the server's signatures. The generated RSA key pair must have key lengths of 2048 bits and adhere to the PKCS #8 standard. Request signing example Consider the following request, a POST to /v1/user/126/monetary-account/222/payment (the JSON is formatted with newlines and indentations to make it more readable): Header Value Cache-Control: no-cache User-Agent: bunq-TestServer/1.00 sandbox/0.17b3 X-Bunq-Client-Authentication: f15f1bbe1feba25efb00802fa127042b54101c8ec0a524c36464f5bb143d3b8b Let's sign that request. First create a variable $dataToSign containing the body of the request: Next, create the signature of $dataToSign using the SHA256 algorithm and the private key $privateKey of the Installation's key pair. In PHP, use the following to create a signature. The signature will be passed by reference into $signature. openssl_sign($dataToSign, $signature, $privateKey, OPENSSL_ALGO_SHA256); Encode the resulting $signature using base64, and add the resulting value to the request under the X-Bunq-Client-Signature header. You have just signed your request, and can send it! Response verifying example The response to the previous request is as follows (the JSON is formatted with newlines and indentations to make it more readable): Header Value Access-Control-Allow-Origin: * Content-Type: application/json Date: Thu, 07 Apr 2016 08:32:04 GMT Server: APACHE Strict-Transport-Security: max-age=31536000 Transfer-Encoding: chunked X-Bunq-Client-Response-Id: 89dcaa5c-fa55-4068-9822-3f87985d2268 X-Bunq-Client-Request-Id: 57061b04b67ef X-Bunq-Server-Signature: ee9sDfzEhQ2L6Rquyh2XmJyNWdSBOBo6Z2eUYuM4bAOBCn9N5vjs6k6RROpagxXFXdGI9sT15tYCaLe5FS9aciIuJmrVW/SZCDWq/nOvSThi7+BwD9JFdG7zfR4afC8qfVABmjuMrtjaUFSrthyHS/5wEuDuax9qUZn6sVXcgZEq49hy4yHrV8257I4sSQIHRmgds4BXcGhPp266Z6pxjzAJbfyzt5JgJ8/suxgKvm/nYhnOfsgIIYCgcyh4DRrQltohiSon6x1ZsRIfQnCDlDDghaIxbryLfinT5Y4eU1eiCkFB4D69S4HbFXYyAxlqtX2W6Tvax6rIM2MMPNOh4Q== X-Frame-Options: SAMEORIGIN We need to verify that this response was sent by the bunq server and not from a man-in-the-middle: - Create a $dataToSign variable containing the body of the request. NOTE: We started to only sign the response body on April 28, 2020. Please make sure you validate our new response signature. So for our example above the response to sign will look like this: Now, verify the signature of $dataToVerify using the SHA256 algorithm and the public key $publicKey of the server. In PHP, use the following to verify the signature. openssl_sign($dataToVerify, $signature, $publicKey, OPENSSL_ALGO_SHA256); Troubleshooting If you get an error telling you \"The request signature is invalid\", please check the following: - There are no redundant characters (extra spaces, trailing line breaks, etc.) in the data to sign. - Make sure the body is appended to the data to sign exactly as you're adding it to the request. - You have added the full body to the data to sign. - You use the data to sign to create a SHA256 hash signature. - You have base64 encoded the SHA256 hash signature before adding it to the request under X-Bunq-Client-Signature. Headers HTTP headers allow your client and bunq to pass on additional information along with the request or response. While this is already implemented in our SDKs, please follow these instructions to make sure you set appropriate headers for calls if using bunq API directly. Request headers Mandatory request headers Cache-Control Cache-Control: no-cache The standard HTTP Cache-Control header is required for all requests. User-Agent User-Agent: bunq-TestServer/1.00 sandbox/0.17b3 The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header. X-Bunq-Client-Signature ⚠️ UPCOMING CHANGE: Header and URL signature will stop being validated on April 28, 2020. Please sign the request body only. X-Bunq-Client-Signature: XLOwEdyjF1d+tT2w7a7Epv4Yj7w74KncvVfq9mDJVvFRlsUaMLR2q4ISgT+5mkwQsSygRRbooxBqydw7IkqpuJay9g8eOngsFyIxSgf2vXGAQatLm47tLoUFGSQsRiYoKiTKkgBwA+/3dIpbDWd+Z7LEYVbHaHRKkEY9TJ22PpDlVgLLVaf2KGRiZ+9/+0OUsiiF1Fkd9aukv0iWT6N2n1P0qxpjW0aw8mC1nBSJuuk5yKtDCyQpqNyDQSOpQ8V56LNWM4Px5l6SQMzT8r6zk5DvrMAB9DlcRdUDcp/U9cg9kACXIgfquef3s7R8uyOWfKLSNBQpdVIpzljwNKI1Q X-Bunq-Client-Authentication X-Bunq-Client-Authentication: 622749ac8b00c81719ad0c7d822d3552e8ff153e3447eabed1a6713993749440 The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call: - Pass the installation Token you get in the response to the POST /installation call in the /device-server and /session-server calls. - Pass the session Token you get in the response to the POST /session-server call in all the other calls. Optional request headers X-Bunq-Language X-Bunq-Language: en_US en_US is the default language setting for responses and error descriptions. The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US. X-Bunq-Region X-Bunq-Region: en_US en_US is the default region for localization formatting. The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. X-Bunq-Client-Request-Id X-Bunq-Client-Request-Id: a4f0de This header has to specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer. X-Bunq-Geolocation X-Bunq-Geolocation: 4.89 53.2 12 100 NL X-Bunq-Geolocation: 0 0 0 0 000 (if no geolocation is available or known) This header has to specify the geolocation of the device. It makes it possible for bunq to map the geolocation with the payment. ‌ The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued. Attachment headers Content-Type Content-Type: image/jpeg This header should be used when uploading an attachment to pass its MIME type. Supported types are: image/png, image/jpeg and image/gif. X-Bunq-Attachment-Description X-Bunq-Attachment-Description: Check out these cookies. This header should be used when uploading an Attachment's content to give it a description. Response headers All Responses X-Bunq-Client-Request-Id X-Bunq-Client-Request-Id: a4f0de The same ID that was provided in the request's X-Bunq-Client-Request-Id header. Is included in the response (and request) signature, so can be used to ensure this is the response for the sent request. X-Bunq-Client-Response-Id X-Bunq-Client-Response-Id: 76cc7772-4b23-420a-9586-8721dcdde174 A unique ID for the response formatted as a UUID. Clients can use it to add extra protection against replay attacks. X-Bunq-Server-Signature X-Bunq-Server-Signature: XBBwfDaOZJapvcBpAIBT1UOmczKqJXLSpX9ZWHsqXwrf1p+H+eON+TktYksAbmkSkI4gQghw1AUQSJh5i2c4+CTuKdZ4YuFT0suYG4sltiKnmtwODOFtu1IBGuE5XcfGEDDSFC+zqxypMi9gmTqjl1KI3WP2gnySRD6PBJCXfDxJnXwjRkk4kpG8Ng9nyxJiFG9vcHNrtRBj9ZXNdUAjxXZZFmtdhmJGDahGn2bIBWsCEudW3rBefycL1DlpJZw6yRLoDltxeBo7MjgROBpIeElh5qAz9vxUFLqIQC7EDONBGbSBjaXS0wWrq9s2MGuOi9kJxL2LQm/Olj2g== The server's signature for this response. See the signing page for details on how to verify this signature. Warning header X-Bunq-Warning X-Bunq-Warning: \"You have a negative balance. Please check the app for more details.\" Used to inform you on situations that might impact your bunq account and API access. Errors Familiar HTTP response codes are used to indicate the success or failure of an API request. Generally speaking, codes in the 2xx range indicate success, while codes in the 4xx range indicate an error having to do with provided information (e.g. a required parameter was missing, insufficient funds, etc.). Finally, codes in the 5xx range indicate an error with bunq servers. If this is the case, please stop by the support chat and report it to us. Response codes Code Error Description 200 OK Successful HTTP request 399 NOT MODIFIED Same as a 304, it implies you have a local cached copy of the data 400 BAD REQUEST Most likely a parameter is missing or invalid 401 UNAUTHORISED Token or signature provided is not valid 403 FORBIDDEN You're not allowed to make this call 404 NOT FOUND The object you're looking for cannot be found 405 METHOD NOT ALLOWED The method you are using is not allowed for this endpoint 429 RATE LIMIT Too many API calls have been made in a too short period 466 REQUEST SIGNATURE REQUIRED Request signature is required for this operation. 490 USER ERROR Most likely a parameter is missing or invalid 491 MAINTENANCE ERROR bunq is in maintenance mode 500 INTERNAL SERVER ERROR Something went wrong on bunq's end All errors 4xx code errors will include a JSON body explaining what went wrong. Rate limits If you are receiving the error 429, please make sure you are sending requests at rates that are below our rate limits. Our rate limits per IP address per endpoint: - GET requests: 3 within any 3 consecutive seconds - POST requests: 5 within any 3 consecutive seconds - PUT requests: 2 within any 3 consecutive seconds - Callbacks: 2 callback URLs per notification category We have a lower rate limit for /session-server: 1 request within 30 consecutive seconds. API conventions Make sure to follow these indications when using the bunq API or get started with our SDKs. Responses All JSON responses have one top level object. In this object will be a Response field of which the value is always an array, even for responses that only contain one object. Example response body Errors - Error responses also have one top level Error object. - The contents of the array will be a JSON object with an error_description and error_description_translated field. - The error_description is an English text indicating the error and the error_description_translated field can be shown to end users and is translated into the language from the X-Bunq-Language header, defaulting to en_US. - When using bunq SDKs, error responses will be always raised in form of an exception. Example response body Object Type indications When the API returns different types of objects for the same field, they will be nested in another JSON object that includes a specific field for each one of them. Within bunq SDKs a BunqResponse object will be returned as the top level object. In this example there is a field content, which can have multiple types of objects as value such as — in this case — ChatMessageContentText. Be sure to follow this convention or use bunq SDKs instead. Time formats Times and dates being sent to and from the API are in UTC. The format that should be used is YYYY-MM-DD hh:mm:ss.ssssss, where the letters have the meaning as specified in ISO 8601. For example: 2017-01-13 13:19:16.215235. Callbacks Callbacks are used to send information about events on your bunq account to a URL of your choice, so that you can receive real-time updates. Notification Filters To receive notifications for certain activities on a bunq account, you have to create notification filters. It is possible to send the notifications to a provided URL and/or the user’s phone as push notifications. Use the notification-filter-push resource to create and manage push notification filters. Provide the type of events you want to receive notifications about in the category field. Use the notification-filter-url resource to create and manage URL notification filters. The callback URL you provide in the notification_target field must use HTTPS. Callback categories Category Description BILLING notifications for all bunq invoices CARD_TRANSACTION_SUCCESSFUL notifications for successful card transactions CARD_TRANSACTION_FAILED notifications for failed card transaction CHAT notifications for received chat messages DRAFT_PAYMENT notifications for creation and updates of draft payments IDEAL notifications for iDEAL-deposits towards a bunq account SOFORT notifications for SOFORT-deposits towards a bunq account MUTATION notifications for any action that affects a monetary account’s balance OAUTH notifications for revoked OAuth connections PAYMENT notifications for payments created from, or received on a bunq account (doesn’t include payments that result out of paying a Request, iDEAL, Sofort or Invoice). Outgoing payments have a negative value while incoming payments have a positive value REQUEST notifications for incoming requests and updates on outgoing requests SCHEDULE_RESULT notifications for when a scheduled payment is executed SCHEDULE_STATUS notifications about the status of a scheduled payment, e.g. when the scheduled payment is updated or cancelled SHARE notifications for any updates or creation of Connects (ShareInviteBankInquiry) TAB_RESULT notifications for updates on Tab payments BUNQME_TAB notifications for updates on bunq.me Tab (open request) payments SUPPORT notifications for messages received from us through support chat Mutation category A Mutation is a change in the balance of a monetary account. So, for each payment-like object, such as a request, iDEAL-payment or a regular payment, a Mutation is created. Therefore, the MUTATION category can be used to keep track of a monetary account's balance. Receiving callbacks Callbacks for the sandbox environment will be made from different IP's at AWS. Callbacks for the production environment will be made from 185.40.108.0/22. The IP addresses might change. We will notify you in a timely fashion if such a change would take place. Retry mechanism When the execution of a callback fails (e.g. if the callback server is down or the response contains an error) it is tried again for a maximum of 5 times, with an interval of one minute between each try. If your server is not reachable by the callback after the 6th total try, the callback is not sent anymore. Removing callbacks To remove callbacks for an object, send a PUT request to the user-person, user-company, monetary-account or cash-register resource with the notification_filters field of the JSON request body unset. Certificate pinning We recommend you use certificate pinning as an extra security measure. With certificate pinning, we check the certificate of the server on which you want to receive callbacks against the pinned certificate that has been provided by you and cancel the callback if that check fails. How to set up certificate pinning Retrieve the SSL certificate of your server using the following command: 1. openssl s_client -servername www.example.com -connect www.example.com:443 www.example.com.pem 2. POST the certificate to the certificate-pinned endpoint. Now every callback that is made will be checked against the pinned certificate that you provided. Note that if the SSL certificate on your server expires or is changed, our callbacks will fail. Pagination In order to control the size of the response of a LIST request, items can be paginated. A LIST request is a request for every one of a certain resources, for instance all payments of a certain monetary account GET /v1/user/1/monetary-account/1/payment). You can decide on the maximum amount of items of a response by adding a count query parameter with the number of items you want per page to the URL. For instance: GET /v1/user/1/monetary-account/1/payment?count=25 When no count is given, the default count is set to 10. The maximum count you can set is 200. With every listing, a Pagination object will be added to the response, containing the URLs to be used to get the next or previous set of items. The URLs in the Pagination object can be used to navigate through the listed resources. The Pagination object looks like this given a count of 25: The newer_url value can be used to get the next page. The newer_id is always the ID of the last item in the current page. If newer_url is null, there are no more recent items before the current page. The older_url value can be used to get the previous page. The older_id is always the ID of the first item in the current page. If older_url is null, there are no older items after the current page. The future_url can be used to refresh and check for newer items that didn't exist when the listing was requested. The newer_id will always be the ID of the last item in the current page. future_url will be null if newer_id is not also the ID of the latest item. Sandbox The sandbox base URL is https://public-api.sandbox.bunq.com/v1/ We do not use real money and do not allow external transactions in the sandbox environment. Sandbox user accounts You need to create a sandbox user to test the bunq API. The easiest way to do it is by using our developer portal: 1. Log in using your bunq account or create a free developer account with sandbox-only access. 1. Go to Sandbox Users. 1. Generate up to 5 users. 1. Use the sandbox API key to create an API context and/or use the user credentials to log in to the sandbox bunq app. Alternative ways to generate sandbox API keys There are 3 other ways you can generate a bunq sandbox API key: connect to Tinker (it will also return login credentials for the sandbox app)*; create it in the sandbox app (you need to be logged in as a sandbox user)*; * call the sandbox user endpoints directly, using our Postman collection, or by running a cURL command (change sandbox-user-person to sandbox-user-company to generate a business user): ⚠️ NOTE: An API key can only be assigned to an IP within 1 hour after its creation. After the 1 hour, it will become invalid if not assigned. API keys that are created via the sandbox app are wiped with each sandbox reset. Once you have a sandbox API key, create more sandbox users to use as test customer accounts, and start playing with the API. The sandbox base URL is https://public-api.sandbox.bunq.com/v1/. Sandbox money Without money, it's not always sunny in the sandbox world. Fortunately, getting money on the bunq sandbox is easy. All you need to do is ask Sugar Daddy for it. Send a POST v1/request-inquiry request passing sugardaddy@bunq.com in the counterparty_alias field. Specify the type for the alias and set the allow_bunqme field. Request up to €500 at a time. Android Emulator In case you do not own an Android device on which you can run our Sandbox app for end-to-end testing, you can set up an emulator to run the bunq Sandbox app for Android. Things you will need - The bunq Sandbox App APK that's optimised for emulating; - Android Studio. Starting the Android Virtual Device (AVD) Manager 1. Open Android Studio. 2. From the top menu, select “Tools” > \"Android\" > \"AVD Manager\". Setting up a new virtual device 1. Start the wizard by clicking on \"+ Create Virtual Device\". 2. Select a device (recommendation: \"Pixel 5.0\" or \"Nexus 6\") and press \"Next\". 3. Select an x86 system image (recommendation: Nougat, API Level 25, Android 7.1.1 with Google APIs) and press \"Next\". The image needs to have Google Play Services 10.0.1 or higher. 4. In the bottom left corner, select \"Show Advanced Settings\". 5. Scroll to \"Memory and Storage\". 6. Change \"Internal Storage\" to \"2048 MB\". 7. Change \"SD card\" to \"200 MB\". 8. Press \"Finish\". Starting the virtual device 1. On the right side under \"Actions\", select the green \"Play\" button. 2. Wait for the device to boot, this may take a few minutes. Installing the bunq Sandbox App APK 1. Open the command line. 2. Navigate to your Android SDK platform tools directory (e.g. cd ~/Library/Android/sdk/platform-tools on macOS). 3. Make sure that the virtual device is started and has fully booted. 4. Run ./adb install ~/Downloads/bunq-android-sandboxEmulator-public-api.apk, this may take a few minutes, and should finish with \"Success\". Creating an account or logging in 1. Create a sandbox account in the developer portal. 1. Log in to the sandbox app using the sandbox user credentials. ℹ️ You will be asked to verify your phone number when you open the app for the first time. Sandbox does not send actual SMS messages. Enter any valid phone number and use the default verification code 992266. If you couldn't generate a sandbox account in the developer portal, use Tinker: 1. Install Tinker. 1. Run tinker/user-overview to create a sandbox account. The output of the command will include the login credentials for the sandbox account. ⚠️ NOTE: It is not possible to create accounts using the regular signup in the app, bunq is not reviewing Sandbox applications. Moving to Production Have you tested your bunq integration to the fullest and are you now ready to introduce it to the world? Then the time has come to move it to a production environment! To get started you'll need some fresh API keys for the production environment, which you can create via your bunq app. You can create these under \"Profile\" by tapping the \"Security\" menu. We do, however, highly recommend using a standard API Key instead of a Wildcard API Key. The former is significantly safer and it protects you from intrusions and possible attacks. There's only a few things to do before your beautiful bunq creation can be moved to production. You're going to have to change your API Key and redo the sequence of calls to open a session. The bunq Public API production environment is hosted at https://api.bunq.com. Do you have any questions or remarks about the process, or do you simply want to show off with your awesome creations? Don't hesitate to drop us a line on together.bunq.com. Please be aware that if you will gain access to account information of other bunq users or initiate a payment for them, you maybrequire a PSD2 permit. Quickstart: Opening a Session Goal So, you want to start using the bunq API, awesome! To do this, you have to open a session in which you will be making those calls. Getting an API key To connect to the API, you have to make sure you have received an API key. For production: 1. create an app in the developer portal, or 1. generate it in the bunq app (Profile → Security & Settings → Developers → API keys). For sandbox You can use one of the following ways: - create a sandbox user in the developer portal; - generate an API key in the sandbox app (Profile → Security & Settings → Developers → API keys); - get an API key from Tinker; - run a cURL request: curl https://public-api.sandbox.bunq.com/v1/sandbox-user-person -X POST --header \"Content-Type: application/json\" --header \"Cache-Control: none\" --header \"User-Agent: curl-request\" --header \"X-Bunq-Client-Request-Id: $(date)randomId\" --header \"X-Bunq-Language: nl_NL\" --header \"X-Bunq-Region: nl_NL\" --header \"X-Bunq-Geolocation: 0 0 0 0 000\". Use sandbox-user-company to generate a business user. Note that production API key is only usable on production and sandbox key is only usable on sandbox. Sandbox key has a sandbox_ prefix while production key does not have any noticeable prefixes. Call sequence The calls you need to perform to set up a session from scratch are the following: 1. POST installation Each call needs to be signed with your own private key. An Installation is used to tell the server about the public key of your key pair. The server uses this key to verify your subsequent calls. Start by generating a 2048-bit RSA key pair. You can find examples by looking at the source code of the sdk's located at github. Headers On the headers page you can find out about the mandatory headers. Take care that if you are in the sandbox environment, you set an Authorization header. Specific to the POST /installation call, you shouldn't use the X-Bunq-Client-Authentication or the X-Bunq-Client-Signature headers. Body Post your public key to the Installation endpoint (use \\n for newlines in your public key). Response Save the Installation token and the bunq API's public key from the response. This token is used in the Authentication header to register a DeviceServer and to start a SessionServer. The bunq API's public key should be used to verify future responses received from the bunq API. 2. POST device-server Further calls made to the server need to come from a registered device. POST /device-server registers your current device and the IP address(es) it uses to connect to the bunq API. Headers Use the token you received from POST /installation in the X-Bunq-Client-Authentication header. Make sure you sign your call, passing the call signature in X-Bunq-Client-Signature header. Body For the secret, use the API key you received. If you want to create another API key, you can do so in the bunq sandbox app (or production app for the production environment). Login, go to Profile > Security and tap 'API keys'. The freshly created API key can be assigned to one or multiple IP addresses using POST device-server within 4 hours before becoming invalid. As soon as you start using your API key, it will remain valid until the next sandbox reset. For the secret, use the API key you received. 3. POST session-server To make any calls besides installation and device-server, you need to open a session. Headers Use the token you received from POST /installation in the X-Bunq-Client-Authentication header. Make sure you sign your call, passing the call signature in X-Bunq-Client-Signature header. Body For the secret, use the API key you received. Response The token received in the response to POST /session-server should be used to authenticate your calls in this session. Pass this session's token in the X-Bunq-Client-Authentication header on every call you make in this session. Quickstart: Payment Request Goal You want to offer bunq payments on a website or in an application. Scenario In this use case the consumer and the merchant both have a bunq account. The consumer wants to pay with bunq and enters their alias in the bunq payment field at checkout. The merchant sends the request for payment to the consumer when the consumer presses enter. The consumer agrees to the request in the bunq mobile app and the merchant has immediate confirmation of the payment. Please be aware that if you will gain access to account information of other bunq users or initiate a payment for them, you require a PSD2 permit. Before you start Make sure that you have opened a session and that for any call you make after that, you pass the session’s token in the X-Bunq-Client-Authentication header. Call Sequence The consumer is at checkout and selects the bunq payment method. This would be a logical time to open a session on the bunq server. 1. LIST monetary-account When a request for payment is accepted, the money will be deposited on the bank account the request for payment is connected to. Let’s start by finding all your available bank accounts. Pick one of them to make the request for payment with and save its id. 2. POST monetary-account attachment (optional) Optionally, you can attach an image to the request for payment. Headers Make sure you set the Content-Type header to match the MIME type of the image. It’s also required you pass a description of the image via the X-Bunq-Attachment-Description header. Body The payload of this request is the binary representation of the image file. Do not use any JSON formatting. Response Save the id of the posted attachment. You’ll need it to attach it to the request for payment. 3. POST request-inquiry Next, create a request inquiry. A request inquiry is the request for payment that your customer can respond to by accepting or rejecting it. Body Pass the customer’s email address, phone number or IBAN in the counterparty_alias. Make sure you set the correct type for the alias, depending on what you pass. When providing an IBAN, a name of the counterparty_alias is required. You can provide the id of the created attachment. Response You will receive the id of the created request inquiry in the response. Save this id. You will need it to check if the customer has responded to the request yet. 4. GET request-inquiry After you’ve sent the request for payment, its status can be checked. Response When the status is ACCEPTED, the customer has accepted and paid the request, and you will have received the money on the connected monetary account. If the status is REJECTED, the customer did not accept the request. Quickstart: Create a Tab payment Goal You will create a tab that can be paid once by a single user, a so called TagUsageSingle, and explore three different ways to make the Tab visible to your customers: - QR code from the CashRegister - QR code from the Tab. Before you start Make sure that you have opened a session and that for any call you make after that, you pass the session’s token in the X-Bunq-Client-Authentication header. Call sequence 1. POST attachment-public Start by creating an attachment that will be used for the avatar for the cash register. Header Make sure you set the Content-Type header to match the MIME type of the image. It is also required you pass a description of the image via the X-Bunq-Attachment-Description header. Body The payload of this request is the binary representation of the image file. Do not use any JSON formatting. Response Save the uuid of the posted attachment. You'll need it to create the avatar in the next step. 2. POST avatar Make an avatar using the public attachment you've just created. Body The payload of this request is the uuid of the attachment public. Response In response, you’ll receive the UUID of the avatar created using the attachment. Save this UUID. You’ll use it as the avatar for the cash register you're about to create. 3. LIST monetary-account Get a listing of all available monetary accounts. Choose one, and save the id of the monetary account you want your cash register to be connected to. Each paid tab for the cash register will transfer the money to this account. 4a. POST cash-register Create a cash register. Use the id of the monetary account you want to connect the cash register to in the URL of the request. Body In the body provide the uuid of the avatar you created for this cash register. Also make sure to provide a unique name for your cash register. Set the status to PENDING_APPROVAL. Response The response contains the id of the cash register you created. Save this id. You will need it to create subsequent tabs and tab items. 4b. Wait for approval On the production environment, a bunq admin will review and approve your cash register. In the sandbox environment, your cash register will be automatically approved. 5. POST tab-usage-single Create a new tab that is connected to your cash register. Use the id of the cash register you want to connect this tab to in the URL of your request. Body Give the tab a name in merchant_reference. Create the tab with status OPEN, and give the tab a starting amount. You can update this amount later. Response The response contains the uuid of the tab you created. 6. POST tab-item (optional) You can add items to a tab. For instance, if a customer will be paying for multiple products via this tab, you can decide to add an item for each of these. Adding items to a tab is optional, and adding them will not change the total amount of the tab itself. However, if you've added any tab items the sum of the amounts of these items must be equal to the total_amount of the tab when you change its status to WAITING_FOR_PAYMENT. 7. PUT tab-usage-single Update the status of the tab to WAITING_FOR_PAYMENT if you want the costumer to pay the tab, and you're done adding any tab items. You can use this request to make the tab visible for your costumers. Visibility To decide how you are going to make your tab visible, pass a visibility object in the payload. Setting cash_register_qr_code to true will connect this tab to the QR code from the cash register. If this cash register does not have a QR code yet, one will be created. Only one Tab can be connected to the cash register’s QR code at any given time. Setting tab_qr_code to true will create a QR code specifically for this tab. This QR code can not be linked to anything else. Quickstart: Create a TransferWise payment Goal You want to send a payment in currency other than euro outside the SEPA zone. Before you start Make sure that you have opened a session and that for any call you make after that, you pass the session’s token in the X-Bunq-Client-Authentication header. ℹ️ bunq relies on TransferWise for international, so you need to create a TransferWise account linked to a bunq account to be able to create international transfers. You can do it either from the bunq app or using our API as described below. Get the up-to-date exchange rate (optional) You might want to check the latest currency exchange rate before making a transfer. Here’s how you can do it using the bunq API: 1. Check the list of supported currencies via GET /user/{userID}/transferwise-currency. Copy the needed currency code. 2. Create a temporary quote for the currency of your choice via POST /user/{userID}/transferwise-quote-temporary. ℹ️ A quote is the exchange rate at the exact timestamp. Temporary quotes carry solely informative value and cannot be used for creating a transfer. 3. Read the temporary quote via GET /user/{userID}/transferwise-quote-temporary/{transferwise-quote-temporaryID}. Create a TransferWise account You need a TransferWise account linked to your bunq account to make TransferWise payments via the bunq API. Create one via POST /user/{userID}/transferwise-user, and save its ID. ℹ️ You cannot use an existing TransferWise account. Create a quote 1. Create a quote via POST /user/{userID}/transferwise-quote and save its ID. ℹ️ Use amount_target to indicate the sum the recipient must get. Amount_source, on the other hand, will indicate the sum you want to send, but it will not necessarily be the final sum the recipient gets. ℹ️ Quotes are valid for 30 minutes so if you do not manage to create a transfer within this time, you will need to create another quote. 2. Get the exchange rate by reading the quote via GET /user/{userID}/transferwise-quote/(transferwise-quoteID). Create a recipient If you have sent money via the TransferWise account linked to your bunq account, you can reuse the recipients. You can list their IDs via GET /user/{userID}/transferwise-quote/{transferwise-quoteID}/transferwise-recipient. To create a new, previously unused recipient, follow these steps: 1. Retrieve the fields required for creating the recipient as the requirements vary for the type of recipient in each country. Iterate sending the following request pair till there are no more required fields: - GET /user/{userID}/transferwise-quote/{transferwise-quoteID}/transferwise-recipient-requirement - POST /user/{userID}/transferwise-quote/{transferwise-quoteID}/transferwise-recipient-requirement 2. Create a recipient account using the final request body from the previous step with POST /user/{userID}/transferwise-quote/{transferwise-quoteID}/transferwise-recipient-requirement Create a transfer Finally, having both the quote ID and the recipient ID, you can create a transfer. 🎉 1. Check if there are any additional transfer requirements via POST /user/{userID}/transferwise-quote/{transferwise-quoteID}/transferwise-transfer-requirement. 2. Create a transfer via POST /user/{userID}/transferwise-quote/{transferwise-quoteID}/transferwise-transfer`. You need to specify the ID of the monetary account from which you want the payment to be made. Quickstart: Downloading attachments Goal Export receipts and invoices attached to payments to your application. The scenario you want to achieve 0. The bunq user has accepted the authorization request and your application can read the bunq user’s account information. 1. Your application imports all the transactions and attachments. 2. The bunq user sees the transactions matched with the receipts and invoices in your application. Before you start * Make sure that you have opened a session * Make sure you pass the session Token in the X-Bunq-Client-Authentication header in all the following requests of the session. Call sequence 1. List the payments of the user via GET /user/{userID}/monetary-account/{monetary-accountID}/payment. 2. Check if the payments have attachments via GET /user/{userID}/monetary-account/{monetary-accountID}/payment/{paymentID}/note-attachment. Save the attachment IDs. 3. Export the raw content of the attachments via GET /user/{userID}/attachment/{attachmentID}/content. HINT: You can use callbacks to make sure you don’t miss anything happening on the bunq account.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "bunq Developer Support",
      "documentation_url": "http://bunq.com/developer",
      "version": "1.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "bunq API",
      "paths_count": 254,
      "schemas_count": 627
    }
  },
  {
    "name": "automata_market_intelligence_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/byautomata.io/1.0.1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This document provides the documentation for the Market Intelligence API by Automata. Get your API Key at https://apis.byautomata.io and check out our Postman Collection.The root API endpoint is https://api.byautomata.io. Please refer to the code samples for examples of how to call the Market Intelligence API. The ContentPro endpoints (/contentpro-search and /contentpro-similar-text) are not included in the standard Market Intelligence API plans. Please contact support@byautomata.io for access.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "byautomata.io",
      "documentation_url": "http://byautomata.io",
      "version": "1.0.1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Automata Market Intelligence API",
      "paths_count": 4,
      "schemas_count": 7
    }
  },
  {
    "name": "callfire_api_documentation",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/callfire.com/V2/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "CallFire",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "CallFire",
      "documentation_url": "https://www.callfire.com",
      "version": "V2",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "CallFire API Documentation",
      "paths_count": 89,
      "schemas_count": 125
    }
  },
  {
    "name": "chain49_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/chain49.com/2.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Kickstart your next crypto project - extended trezor/blockbook API with 10+ blockchains available instantly and 50+ possible on request running on the finest hardware in Germany's best datacenters at Hetzner Websocket only via api.chain49.com endpoint possible (RapidAPI does not support it yet)",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "chain49.com",
      "documentation_url": "https://chain49.com/",
      "version": "2.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Chain49 API",
      "paths_count": 18,
      "schemas_count": 0
    }
  },
  {
    "name": "chaingateway_io_v2",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/chaingateway.io/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This API allows you to interact with Ethereum, Binance smart chain, Polygon and Tron blockchain. If you ever looked for a possibility to automate token or payments this is the right place. You still have no idea for real use cases? Let me give you some examples: Accept your own token as payment method for your shop, distribute airdrop tokens of your ICO, convert your site currency to a token that can be traded on exchanges and many more. There are a lot of use cases which are not only limited to sending tokens but also receiving them. You could even create a secure wallet for your token which only the wallet owner has access to. Additionally we offer a lot of functions for retrieving blockchain data, including transactions. Using our webhook system, it is possible to receive notifications when events on the blockchain occur, for example when a transfer to a specific address is happening. Registering To use this Blockchain API, you need to register for a free account on Chaingateway.io Once you have created your account, you can create an API key in your Account panel to use with our API. Postman Postman is a great software to test APIs, it helped us a lot when developing this API. If you haven't installed it yet, we recommend to do so We have created a Postman collection that allows to import all functions and their settings, including descriptions in Postman. This way you can test all functions with the click of a button (just change the parameters before). API Specifications For many API clients, websites and development projects you may need a file which specifies all function endpoints of our API. These files can be found in our Github repository, always updated in the formats \"Postman Collection\" and \"OPENAPI/SWAGGER\". Authorization You can get your personal API Key from your account dashboard. It is used by us to determine who is accessing the API and to count the requests by that account. There are 2 possibilities to use it in your requests: Add it in the HTTP header as Authorization: q9PdaWuD4j6DK6vsUgehhL8pgarSrS9m Please do not share your api key! If you did so by mistake, immediately regenerate it in your account panel!",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "chaingateway.io",
      "documentation_url": "https://chaingateway.io",
      "version": "1.0.0",
      "openapi_version": "3.0.3",
      "quality_score": 100,
      "is_popular": false,
      "title": "Chaingateway.io V2",
      "paths_count": 109,
      "schemas_count": 0
    }
  },
  {
    "name": "channel_4_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/channel4.com/1.0.0/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is the place to come for all the technical details you need to power your applications with Channel 4's deep programmes data.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Open C4 Project",
      "documentation_url": "http://developer.channel4.com/docs/read/ProgrammesAPIGuide",
      "version": "1.0.0",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Channel 4 API",
      "paths_count": 68,
      "schemas_count": 23
    }
  },
  {
    "name": "circleci_rest_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/circleci.com/v1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The CircleCI API is a RESTful, fully-featured API that allows you to do almost anything in CircleCI. You can access all information and trigger all actions. The only thing we don’t provide access to is billing functions, which must be done from the CircleCI web UI.",
      "category": "Finance & Payments",
      "last_updated": "2025-08-03",
      "maintainer": "circleci.com",
      "documentation_url": "https://circleci.com",
      "version": "v1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "CircleCI REST API",
      "paths_count": 17,
      "schemas_count": 28
    }
  },
  {
    "name": "rest_api_version_2",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/circuitsandbox.net/2.9.235/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Circuit REST API to interact with the Circuit system. Learn more about the Circuit Development Community",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "circuitsandbox.net",
      "documentation_url": "https://circuitsandbox.net",
      "version": "2.9.235",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "REST API Version 2",
      "paths_count": 100,
      "schemas_count": 60
    }
  },
  {
    "name": "clearblade_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/clearblade.com/3.0/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "A friendly little API to help you interact with the ClearBlade platform.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "clearblade.com",
      "documentation_url": "https://clearblade.com",
      "version": "3.0",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "ClearBlade API",
      "paths_count": 133,
      "schemas_count": 163
    }
  },
  {
    "name": "clever_cloud_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/clever-cloud.com/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Public API for managing Clever-Cloud data and products",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "clever-cloud.com",
      "documentation_url": "https://clever-cloud.com",
      "version": "1.0.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Clever-Cloud API",
      "paths_count": 229,
      "schemas_count": 71
    }
  },
  {
    "name": "clickmeter_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/clickmeter.com/v2/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Api dashboard for ClickMeter API",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Api Support",
      "documentation_url": "http://www.clickmeter.com/api",
      "version": "v2",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "ClickMeter API",
      "paths_count": 75,
      "schemas_count": 55
    }
  },
  {
    "name": "clicksend_rest_api_v3",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/clicksend.com/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is the official API documentation for ClickSend.com Below you will find a current list of the available methods for clicksend. NOTE: You will need to create a free account to use the API. You can Register Here. API URL The API should always be accessed over SSL. Base URL: https://rest.clicksend.com/v3/ Authentication Basic HTTP authentication should be used in the header. Either: username: Your API username password: Your API key OR username: Your account username password: Your account password Authorization Header The Authorization header is constructed as follows: 1. Username and password are combined into a string username:password 1. The resulting string is then encoded using Base64 encoding 1. The authorization method and a space i.e. \"Basic \" is then put before the encoded string. For example, if the user uses Aladdin as the username and open sesame as the password then the header is formed as follows: Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== PHP Authentication Header Example (using cURL) curl_setopt($ch, CURLOPT_HTTPHEADER, ['Authorization: Basic ' . base64_encode(\"$username:$password\")]); Verbs The API uses restful verbs. | Verb | Description | |---|---| | GET | Select one or more items. Success returns 200 status code. | | POST | Create a new item. Success returns 200 status code. | | PUT | Update an item. Success returns 200 status code. | | DELETE | Delete an item. Success returns 200 status code. | Status Codes The API will respond with one of the following HTTP status codes. | Code | Response | Description | |---|---|---| | 200 | SUCCESS | Request completed successfully. | | 400 | BAD_REQUEST | The request was invalid or cannot be otherwise served. An accompanying error message will explain further. | | 401 | UNAUTHORIZED | Authentication credentials were missing or incorrect. | | 403 | FORBIDDEN | The request is understood, but it has been refused or access is not allowed. An accompanying error message will explain why. | | 404 | NOT_FOUND | The URI requested is invalid or the resource requested does not exists. | | 405 | NOT_FOUND | Method doesn't exist or is not allowed. | | 429 | TOO_MANY_REQUESTS | Rate Limit Exceeded. Returned when a request cannot be served due to the application’s rate limit having been exhausted for the resource. See Rate Limiting. | | 500 | INTERNAL_SERVER_ERROR | Something is broken | Application Status Codes The following status codes can be returned in addition to the HTTP status code. For example, when using the Send SMS endpoint: | Response | Description | |---|---| | SUCCESS | Message added to queue OK. Use delivery reports to get an update on the delivery status.| | MISSING_CREDENTIALS | Not enough information has been supplied for authentication. Please ensure that your Username and Unique Key are supplied in your request.| | ACCOUNT_NOT_ACTIVATED | Your account has not been activated.| | INVALID_RECIPIENT | The destination mobile number is invalid.| | THROTTLED | Identical message body recently sent to the same recipient. Please try again in a few seconds.| | INVALID_SENDER_ID | Invalid Sender ID. Please ensure Sender ID is no longer than 11 characters (if alphanumeric), and contains no spaces.| | INSUFFICIENT_CREDIT | You have reached the end of your message credits. You will need to purchase more message credits.| | INVALID_CREDENTIALS | Your Username or Unique Key is incorrect.| | ALREADY_EXISTS | The resource you're trying to add already exists.| | EMPTY_MESSAGE | Message is empty.| | TOO_MANY_RECIPIENTS | Too many recipients.| | MISSING_REQUIRED_FIELDS | Some required fields are missing.| | INVALID_SCHEDULE | The schedule specified is invalid. Use a unix timestamp e.g. 1429170372.| | NOT_ENOUGH_PERMISSION_TO_LIST_ID | Don't have enough privilege to access or send to a list_id.| | INTERNAL_ERROR | Internal error.| | INVALID_LANG | An invalid language option has been provided.| | INVALID_VOICE | An invalid voice (gender) option has been provided.| | SUBJECT_REQUIRED | Usually happens when MMS Subject is empty.| | INVALID_MEDIA_FILE | Usually MMS media file is invalid file.| | SOMETHING_IS_WRONG | Generic Error happened.| Required Headers You'll need to send some headers when making API calls. | Header | Value | |---|---| | Content-type | application/json | Pagination Some methods are paginated. By default, 1 page of 15 items will be returned. You can set the pagination parameters by adding ?page={page}&limit={limit} to the URL. Request | Parameter | Type | Default | Value | |---|---|---|---| | page | integer | 1 | The page number to return in the response. | | limit | integer | 15 | The number of results per page. Min 15, Max 100. | Response | Attribute | Type | Value | |---|---|---|---| | total | integer | Total number of results available. | | per_page | integer | Number of results returned per page. | | current_page | integer | Current page number. | | last_page | integer | Last page number. | | next_page_url | string | A URL of the next page. null if not available.| | prev_page_url | string | A URL of the previous page. null if not available.| | from | integer | Number of the first result in current page. | | to | integer | Number of the last result in current page. | Searching and Sorting Most GET endpoints allow searching and sorting. Searches are not case-sensitive. Search To perform a search, add q as a query parameter. For example: /subaccounts?q=field:value,field2:value Order To perform a sort, add order_by as a query parameter. For example: /subaccounts?order_by=field:desc/asc AND / OR By default, it will search using the AND operator. This can be set using operator as a query parameter. For example: /subaccounts?q=field:value&operator=OR Options: - AN - returns results matching all query fields specified - OR - returns results matching any query fields specified Example /subaccounts?q=first_name:john,last_name:smith&order_by=subaccount_id:asc&operator=AND CORS When creating your API app, specify the JavaScript (CORS) origins you'll be using. We use these origins to return the headers needed for CORS. Date and Time All date/timestamps will be returned in Unix time (also known as POSIX time or erroneously as Epoch time) with no leap seconds. For example: 1435255816 More information: Wikipedia: Unix time. There is ony one Unix time and it is created by using the UTC/GMT time zone. This means you might have convert time zones to calculate timestamps. Most programming language have libraries to help you converting time zones. The current Unix time can be found here: Epoch Converter Testing Test Credentials These API credentials can be used to test specific scenarios. Note: you will need to create a free account to test other scenarios. Refer to introduction. | API Username | API Key | Description | |---|---|---|---| | nocredit | D83DED51-9E35-4D42-9BB9-0E34B7CA85AE | This account has no credit. | | notactive | D83DED51-9E35-4D42-9BB9-0E34B7CA85AE | This account is not active. | | banned | D83DED51-9E35-4D42-9BB9-0E34B7CA85AE | This account is banned. | Test SMS/MMS Numbers The following numbers can be used when testing. No messages will be sent, and your account won't be charged. A success response will be returned. - +61411111111 - +61422222222 - +61433333333 - +61444444444 - +14055555555 - +14055555666 - +447777777777 - +8615555555555 Test Voice Numbers The following numbers can be used when testing. No messages will be sent, and your account won't be charged. A success response will be returned. - +61411111111 - +61422222222 - +61433333333 - +61444444444 - +14055555555 - +14055555666 - +447777777777 - +8615555555555 Test Fax Numbers The following numbers can be used when testing. No messages will be sent, and your account won't be charged. A success response will be returned. - +61261111111 - +61262222222 - +61263333333 Test Email Addresses The following email addresses can be used when testing. No messages will be sent, and your account won't be charged. A success response will be returned. - test1@test.com - test2@test.com - test3@test.com Test Post Letter Addresses The following Postal Codes (address_postal_code) can be used when testing. No messages will be sent when using these post codes, and your account won't be charged. A success response will be returned. - 11111 - 22222 - 33333",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "clicksend.com",
      "documentation_url": "https://clicksend.com",
      "version": "1.0.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "ClickSend REST API v3",
      "paths_count": 150,
      "schemas_count": 84
    }
  },
  {
    "name": "climate_fieldview_platform_apis",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/climate.com/4.0.11/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Last Modified: Wed Jan 4 12:47:29 UTC 2023 All endpoints are only accessible via HTTPS. * All API endpoints are located at https://platform.climate.com (e.g. https://platform.climate.com/v4/fields). * The authorization token endpoint is located at https://api.climate.com/api/oauth/token. Troubleshooting X-Http-Request-Id response header will be returned on every call, successful or not. If you experience an issue with our api and need to contact technical support, please supply the value of the X-Http-Request-Id header along with an approximate time of when the request was made. Request Limits When you’re onboarded to Climate’s API platform, your x-api-key is assigned a custom usage plan. Usage plans are unique to each partner and have the following key attributes: 1. Throttling information * burstLimit: Maximum rate limit over a period ranging from 1 second to a few seconds * rateLimit: A steady-state rate limit 2. Quota information * Limit: The maximum number of requests that can be made in a given month When the request rate threshold is exceeded, a 429 response code is returned. Optionally, the Retry-After header may be returned: Following are examples of rate limit errors: 1. Rate limit exceeded: HTTP/1.1 429 Content-Type: application/json Content-Length: 32 {\"message\":\"Too Many Requests\"} 2. Quota exhausted: HTTP/1.1 429 Content-Type: application/json Content-Length: 29 {\"message\":\"Limit Exceeded\"} Pagination Pagination is performed via headers. Any request which returns a \"results\" array may be paginated. The following figure shows how query results are laid out with X-Limit=4 and no filter applied. * If there are no results, a response code of 304 will be returned. * If the response is the last set of results, a response code of 200 or 206 will be returned. * If there are more results, a response code of 206 will be returned. * If X-Next-Token is provided in the request headers but the token has expired, a response code of 409 will be returned. This is only applicable for some endpoints; see specific endpoint documentation below. X-Limit The page size can be controlled with the X-Limit header. Valid values are 1-100 and defaults to 100. X-Next-Token If the results are paginated, a response header of X-Next-Token will be returned. Use the associated value in the subsequent request (via the X-Next-Token request header) to retrieve the next page. The following sequence diagram shows how to use X-Next-Token to fetch all the records. Chunked Uploads Uploads larger than 5MiB (5242880 bytes) must be done in 5MiB chunks (with the exception of the final chunk). Each chunk request MUST contain a Content-Range header specifying the portion of the upload, and a Content-Type header specifying binary content type (application/octet-stream). Range uploads must be contiguous. The maximum upload size is capped at 500MiB (524288000 bytes). Chunked Downloads Downloads larger than 5MiB (5242880 bytes) must be done in 1-5MiB chunks (with the exception of the final chunk, which may be less than 1MiB). Each chunk request MUST contain a Range header specifying the requested portion of the download, and an Accept header specifying binary and json content types (application/octet-stream,application/json) or all content types (/). Drivers If you need drivers to process agronomic data, download the ADAPT plugin below. We only support the plugin in the Windows environment, minimum is Windows 7 SP1. For asPlanted, asHarvested and asApplied data: * ADAPT Plugin Release notes can be found here. Download and use of the ADAPT plugin means that you agree to the EULA for use of the ADAPT plugin. Please review the EULA (last updated on June 6th, 2019) before download and use of the ADAPT plugin. For more information, please refer to: * ADAPT Resources * ADAPT Overview * ADAPT FAQ * ADAPT Videos Sample Test Data Sample agronomic data: * asPlanted and asHarvested data * asApplied data set 1 * asApplied data set 2 To upload the sample data to your account, please follow the instructions in this link. Sample soil data: * Sample soil data ---",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Climate FieldView Support",
      "documentation_url": "https://climate.com",
      "version": "4.0.11",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Climate FieldView Platform APIs",
      "paths_count": 26,
      "schemas_count": 46
    }
  },
  {
    "name": "cloud_rf_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/cloudrf.com/2.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Use this JSON API to build and test radio links for any radio, anywhere. Authenticate with your API2.0 key in the request header as key",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "cloudrf.com",
      "documentation_url": "https://cloudrf.com",
      "version": "2.0.0",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "Cloud-RF API",
      "paths_count": 11,
      "schemas_count": 8
    }
  },
  {
    "name": "college_football_data_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/collegefootballdata.com/4.4.12/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is an API for accessing all sorts of college football data. Please note that API keys should be supplied with \"Bearer \" prepended (e.g. \"Bearer your_key\"). API keys can be acquired from the CollegeFootballData.com website.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "collegefootballdata.com",
      "documentation_url": "https://collegefootballdata.com",
      "version": "4.4.12",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "College Football Data API",
      "paths_count": 51,
      "schemas_count": 50
    }
  },
  {
    "name": "public_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/combell.com/v2/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Introduction This API allows resellers to manage their resources in a simple, programmatic way using HTTP requests. Conventions Requests The API supports different methods depending on the required action. | Method | Description | --- | --- | GET | Retrieve resources in a collection or get a single resource.Getters will never have any effect on the queried resources. | POST | Create a new resource in a collection. | PUT | Update an existing resource with its new representation. | DELETE | Delete an existing resource. HTTP status codes The API will reply with different HTTP statuscodes: | StatusCode | Description | --- | --- | 200 OK | The requests was processed and you receive data as a result. | 201 CREATED | The resource has been created. Either the Location header contains a link to the created resource, or links are being returned in the response body. The applied method will be indicated in the documentation. | 202 ACCEPTED | The request has been validated and accepted. Because we need to do some background processing prior to returning the result, we cannot send back a useful representation. | 204 NOCONTENT | The request has been processed, but no details can be returned. | 400 BADREQUEST | Your request is malformed. | 401 UNAUTHORIZED | You are not authorized. Follow the instructions in the Authorization documentation. | 403 FORBIDDEN | Access to the resource or operation is not allowed. | 404 NOTFOUND | The resource cannot be found. | 410 GONE | The resource is permanently no longer available. | 429 TOOMANYREQUESTS | The ratelimit has been exceeded. Please refer to the documentation on rate limiting for more details. | 500 INTERNALSERVERERROR | An error occurred during the processing of the request. The error is unexpected and most likely due to a bug in the api. In the event of a problem, the body of the response will usually contain an errorcode and errormessage. In rare cases additional details about the error are reported. Errorcodes 400-499 are considered to be client errors and indicate that there was an issue with the request. We will not take any action besides monitoring. Errorcodes 500-599 are considered to be server errors. The errors are monitored AND action will be taken to resolve the error. Formatting Snake casing is applied on resources and query parameters. The API is strictly returning JSON. No other formats are supported. Datetimes are returned in ISO-8601 format. Pagination Pagination is on by default on collections and is controlled by specifying skip and take parameters. Skip indicates the number of results to skip and where to start the new take. Take indicates the number of records to return. The returned number of items can be smaller than the requested take. Paged results will have headers with useful information regarding the paging. | Header | Description | --- | --- | X-Paging-Skipped | The number of results that have been skipped. | X-Paging-Take | The number of items in the current take. The number might differ from the requested take. It represents the actual number of items returned in the response. | X-Paging-TotalResults | The total number of results regardless of paging. Rate limiting The number of requests per interval is limited. Detailed information on the rate limiting can be found in specific headers which will be sent on each request. | Header | Description | --- | --- | X-RateLimit-Limit | The number of requests that can be made in a specific time interval. | X-RateLimit-Usage | The number of requests already made in the current time interval. | X-RateLimit-Remaining | The number of requests remaining until the reset. | X-RateLimit-Reset | The number of seconds until the reset.After the reset you are allowed to make as many requests as specified by the X-RateLimit-Limit header. | Retry-After | The number of seconds you have to wait until you can make new requests.This header is only present when the rate limit has been reached. It is identical to X-RateLimit-Reset. When the ratelimit has been reached, all requests will return with a HTTP statuscode 429 and ReasonPhrase 'Too many requests, retry later.'. Authentication The Api uses HMAC authentication. Hash-based message authentication code (HMAC) is a mechanism for calculating a message authentication code involving a hash function in combination with a secret key. Both the integrity and the authenticity of the message are verified this way. Steps to generate the HMAC 1. Get your api key and secret from your controlpanel. It is absolutely vital that the secret is never exposed. Once the secret is out, anyone would be able to generate hmacs to impersonate you. In case your secret is compromised, you can generate a new api key and secret on your controlpanel. 2. Construct the input value for generating the hmac. Concatenate:apikey, request method, path and querystring information, unix timestamp, nonce and content. | | Description | --- | --- | apikey | The key that is linked to your user. | request method | lowercased (eg: get, post, delete,...) | path and querystring information | urlencoding of the lowercased relative path and querystring.The path MUST start with the api version (/v2).The hexadecimal codes (percent encoding) MUST be uppercased. | unix timestamp | the unix timestamp in seconds. | nonce | a unique string for each request. It should be a random string, not related to the request. The nonce (in combination with the unix timestamp) protects you from replay attacks in case anyone was able to intercept a request. | content | When the request body is not empty, this should be the Base64 encoded Md5 hash of the request body.An empty body should not be encoded. 3. Hash the concatenated string using your api secret and the SHA-256 algorithm. 4. Base64 encode the result of the hash function. This is the hmac signature you will need to send an authorized request. Sending an authorized request An authorized request can be made by sending the generated HMAC in the authorization header. A correct authorizationheader uses the hmac authorization scheme and a correctly formatted authorization parameter. Create the authorization parameter by concatenating: * apikey * colon ':' * generated HMAC signature (see above) * colon ':' * nonce (the one used to generate the signature) * colon ':' * unix timestamp (the one used to generate the signature) A sample (illustrated): * The first line is the string you create to feed to the hashing algorithm. * The second line is the authorization header that should be sent in the request. !hmac authorization header illustrated IP whitelisting Access is by default restricted for all IP addresses. You need to explicitly whitelist an IP or an IP range in your controlpanel. Versioning Because of breaking contract changes compared to v1, we released v2 of the API. V1 will still be available, but you are strongly encouraged to migrate to the latest version. New features will only be available on v2. Policy Fair use policy Please respect the rate limits and do not use the api for any purposes of abuse. All requests are being monitored and logged. Intentional abuse might result in api key revocation. Errors The API attempts to return appropriate HTTP status codes for every request. When the status code indicates failure, the API will also provide an error message in most cases. An error message contains a machine-parseable error code accompanied by a descriptive error text. The text for an error message might change over time, but codes will stay the same. An overview of error codes can be found here. Change log An overview of new changes can be found here. Provisioning information Terminology | Term | Definition | | --- | --- | | Servicepack | Defines a set of assets that belong together. An example is a hosting package which offers Linux hosting, a domain name, a couple of mailboxes and databases.It also limits the size of individual assets within the same account. | | Account | Represents an instance of the servicepack. It contains one or more assets. The number and size of assets is defined by the servicepack. | | Asset | A manageable service. For example: a mysql database, a linux hosting, a mailbox,...Some assets are created at the moment when the account is created. Other assets can be created afterwards. Common provisioning scenario Provisioning of an account with Linux hosting with one MySql database Without a pre-existing account: 1. Create a new account.Perform a POST on the accounts route and provide the desired servicepack id and identifier (domain name). 2. Read the Location header from the response and perform a GET of the provided resource (a provisioning job). 3. When the response returns 200(OK), you should repeat the GET operation after a certain interval (Repeat this step). When the response returns 201(Created), you should read the response body. This will contain links to the created resources. This will usually hold only one link, but to be futureproof, this has been designed to return a collection. 4. The created resource will point to an account. You now know the account's Id and can continue with the provisioning of a MySql database on this account. 5. Perform a POST on the mysqldatabases route and provide the account id along with other requested information. 6. Read the Location header from the response and perform a GET of the provided resource (a provisioning job). 7. When the response returns 200(OK), you should repeat the GET operation after a certain interval (Repeat this step). When the response returns 201(Created), you should read the response body. This will contain links to the created resources. This will usually hold only one link, but to be futureproof, this has been designed to return a collection. 8. The created resource will point to a MySql database resource. SSL certificate requests Requesting an SSL certificate causes the purchase of a paying product. 1. A certificate is created by adding an ssl certificate request. 2. Upon statuscode 201 you should query for certificate completion on the resource provided in the location response header. 3. The resource request can respond with different statuscodes: 200: the certificate request is ongoing. Check the validations collection for validation values that are not auto_validated. Those should be set by you system. Call verify domain validations once all validation values are in place. It might take some time for verification to take place. It is not necessary to call this method more than once. 303: the certificate request is complete; there is no more certificate request resource available. Check the location header value to retrieve the representation of the resulting ssl certificate. 410: the certificate request does not exist anymore, there is no certificate created as a result of the request.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "combell.com",
      "documentation_url": "https://combell.com",
      "version": "v2",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "Public Api",
      "paths_count": 58,
      "schemas_count": 89
    }
  },
  {
    "name": "configcat_public_management_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/configcat.com/v1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Base API URL: https://api.configcat.com If you prefer the swagger documentation, you can find it here: Swagger UI. The purpose of this API is to access the ConfigCat platform programmatically. You can Create, Read, Update and Delete any entities like Feature Flags, Configs, Environments or Products within ConfigCat. The API is based on HTTP REST, uses resource-oriented URLs, status codes and supports JSON and JSON+HAL format. Do not use this API for accessing and evaluating feature flag values. Use the SDKs instead. OpenAPI Specification The complete specification is publicly available here: swagger.json. You can use it to generate client libraries in various languages with OpenAPI Generator or Swagger Codegen to interact with this API. Authentication This API uses the Basic HTTP Authentication Scheme. --> Throttling and rate limits All the rate limited API calls are returning information about the current rate limit period in the following HTTP headers: | Header | Description | | :- | :- | | X-Rate-Limit-Remaining | The maximum number of requests remaining in the current rate limit period. | | X-Rate-Limit-Reset | The time when the current rate limit period resets. | When the rate limit is exceeded by a request, the API returns with a HTTP 429 - Too many requests status along with a Retry-After HTTP header.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "ConfigCat",
      "documentation_url": "https://configcat.com",
      "version": "v1",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "ConfigCat Public Management API",
      "paths_count": 36,
      "schemas_count": 79
    }
  },
  {
    "name": "conjur",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/conjur.local/5.3.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is an API definition for CyberArk Conjur Open Source. You can find out more at Conjur.org.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "conjur.local",
      "documentation_url": "https://conjur.org",
      "version": "5.3.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Conjur",
      "paths_count": 36,
      "schemas_count": 8
    }
  },
  {
    "name": "contract_fit_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/contract-p.fit/1.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This OpenAPI describes the API exposed by the contract.fit backend. Security Authentication All endpoints are protected: you need to make authenticated calls. There are 3 authentication mechanisms: - HTTP Basic (Username + Password) - JWT Token - API-Key By default you should have an account allowing you to bootstrap your tenant and create users and roles, using Basic Auth or after creating a Token - see /auth endpoints. If you are missing credentials or permissions, please contact us. Authorization The security system is RBAC based: users must be granted scoped roles, allowing them to access resources. Each role grants a defined set of permissions, which can be restricted to a given inbox or document - see /roles endpoints. Upload and Processing Below is a short description of common use cases of the API. Simple Upload The easiest and simplest way to get started is to use POST /documents : it will make a synchronous upload of your file and wait for the result. This is a simplified version of POST /documents/{inbox_id} with less arguments and settings; it may not be suitable for real workload as it offers less capabilities. Upload to Inbox The favored endpoint to upload files is POST /documents/{inbox_id}: it is also highly recommended to make async call using sync=false. Sync / Async For convenience uploads can be synchronous: it will make the request blocks until the document is processed. It is however discouraged to rely on sync requests, as our service is designed to process documents asynchronously. You might run into timeouts and unprocessed document depending on factors such as server load and number of pending documents. Asynchronous calls will only schedule the processing and directly return the document ID without waiting: the document will be processed as soon as possible. You can then wait for the processed result using GET /documents/{document_id}. Reprocessing You can reprocess a document using POST /documents/{document_id}/reprocess : it will schedule an async processing of the document (note: it is not possible to make a sync reprocessing)",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "contract-p.fit",
      "documentation_url": "https://contract-p.fit",
      "version": "1.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Contract.fit API",
      "paths_count": 91,
      "schemas_count": 106
    }
  },
  {
    "name": "corrently_io",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/corrently.io/2.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Corrently - from italian corrente, which is energy Introduction The Corrently ecosystem gets maintained by STROMDAO GmbH to support green energy services for prosumers, grid operators, regulators, integrators or any other party with an emerging need of consensus driven management. As the energy product Corrently got first launched in Germany parts of this documentation provide simple translations for better understanding. Released SKDs for Download",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "corrently.io",
      "documentation_url": "https://stromdao.de/kontakt",
      "version": "2.0.0",
      "openapi_version": "3.0.2",
      "quality_score": 100,
      "is_popular": false,
      "title": "Corrently.io",
      "paths_count": 25,
      "schemas_count": 9
    }
  },
  {
    "name": "daniweb_connect_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/daniweb.com/4/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "User Recommendation Engine and Chat Network",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Dani Wolkowicki",
      "documentation_url": "https://www.daniweb.com/connect/developers",
      "version": "4",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "DaniWeb Connect API",
      "paths_count": 51,
      "schemas_count": 82
    }
  },
  {
    "name": "data2crm_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/data2crm.com/1/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Make use of our in-depth documentation to get more information about the various functions of the service. Those willing to explore the mechanics of Data2CRM.API can test it in live regime using the short code samples.Select CRM: Loading... please waitHere are the API access keys:X-API2CRM-USER-KEY: e2a6379ab878ae7e58119d4ec842bf9cX-API2CRM-APPLICATION-KEY: 7ae5b17008fb414d84981191cf3b66a476ef8befThe CRM access details are:URL: https://login.salesforce.com/E-mail / Username: developers.data2crm.api+1@magneticone.comPassword: data2crmapi123",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "data2crm.com",
      "documentation_url": "http://www.data2crm.com/api/",
      "version": "1",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Data2CRM.API",
      "paths_count": 216,
      "schemas_count": 161
    }
  },
  {
    "name": "digitalocean_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/digitalocean.com/2.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Introduction The DigitalOcean API allows you to manage Droplets and resources within the DigitalOcean cloud in a simple, programmatic way using conventional HTTP requests. All of the functionality that you are familiar with in the DigitalOcean control panel is also available through the API, allowing you to script the complex actions that your situation requires. The API documentation will start with a general overview about the design and technology that has been implemented, followed by reference information about specific endpoints. Requests Any tool that is fluent in HTTP can communicate with the API simply by requesting the correct URI. Requests should be made using the HTTPS protocol so that traffic is encrypted. The interface responds to different methods depending on the action required. |Method|Usage| |--- |--- | |GET|For simple retrieval of information about your account, Droplets, or environment, you should use the GET method. The information you request will be returned to you as a JSON object. The attributes defined by the JSON object can be used to form additional requests. Any request using the GET method is read-only and will not affect any of the objects you are querying.| |DELETE|To destroy a resource and remove it from your account and environment, the DELETE method should be used. This will remove the specified object if it is found. If it is not found, the operation will return a response indicating that the object was not found. This idempotency means that you do not have to check for a resource's availability prior to issuing a delete command, the final state will be the same regardless of its existence.| |PUT|To update the information about a resource in your account, the PUT method is available. Like the DELETE Method, the PUT method is idempotent. It sets the state of the target using the provided values, regardless of their current values. Requests using the PUT method do not need to check the current attributes of the object.| |PATCH|Some resources support partial modification. In these cases, the PATCH method is available. Unlike PUT which generally requires a complete representation of a resource, a PATCH request is is a set of instructions on how to modify a resource updating only specific attributes.| |POST|To create a new object, your request should specify the POST method. The POST request includes all of the attributes necessary to create a new object. When you wish to create a new object, send a POST request to the target endpoint.| |HEAD|Finally, to retrieve metadata information, you should use the HEAD method to get the headers. This returns only the header of what would be returned with an associated GET request. Response headers contain some useful information about your API access and the results that are available for your request. For instance, the headers contain your current rate-limit value and the amount of time available until the limit resets. It also contains metrics about the total number of objects found, pagination information, and the total content length.| HTTP Statuses Along with the HTTP methods that the API responds to, it will also return standard HTTP statuses, including error codes. In the event of a problem, the status will contain the error code, while the body of the response will usually contain additional information about the problem that was encountered. In general, if the status returned is in the 200 range, it indicates that the request was fulfilled successfully and that no error was encountered. Return codes in the 400 range typically indicate that there was an issue with the request that was sent. Among other things, this could mean that you did not authenticate correctly, that you are requesting an action that you do not have authorization for, that the object you are requesting does not exist, or that your request is malformed. If you receive a status in the 500 range, this generally indicates a server-side problem. This means that we are having an issue on our end and cannot fulfill your request currently. 400 and 500 level error responses will include a JSON object in their body, including the following attributes: |Name|Type|Description| |--- |--- |--- | |id|string|A short identifier corresponding to the HTTP status code returned. For example, the ID for a response returning a 404 status code would be \"not_found.\"| |message|string|A message providing additional information about the error, including details to help resolve it when possible.| |request_id|string|Optionally, some endpoints may include a request ID that should be provided when reporting bugs or opening support tickets to help identify the issue.| Example Error Response Responses When a request is successful, a response body will typically be sent back in the form of a JSON object. An exception to this is when a DELETE request is processed, which will result in a successful HTTP 204 status and an empty response body. Inside of this JSON object, the resource root that was the target of the request will be set as the key. This will be the singular form of the word if the request operated on a single object, and the plural form of the word if a collection was processed. For example, if you send a GET request to /v2/droplets/$DROPLET_ID you will get back an object with a key called \"droplet\". However, if you send the GET request to the general collection at /v2/droplets, you will get back an object with a key called \"droplets\". The value of these keys will generally be a JSON object for a request on a single object and an array of objects for a request on a collection of objects. Response for a Single Object Response for an Object Collection Meta In addition to the main resource root, the response may also contain a meta object. This object contains information about the response itself. The meta object contains a total key that is set to the total number of objects returned by the request. This has implications on the links object and pagination. The meta object will only be displayed when it has a value. Currently, the meta object will have a value when a request is made on a collection (like droplets or domains). Sample Meta Object Links & Pagination The links object is returned as part of the response body when pagination is enabled. By default, 20 objects are returned per page. If the response contains 20 objects or fewer, no links object will be returned. If the response contains more than 20 objects, the first 20 will be returned along with the links object. You can request a different pagination limit or force pagination by appending ?per_page= to the request with the number of items you would like per page. For instance, to show only two results per page, you could add ?per_page=2 to the end of your query. The maximum number of results per page is 200. The links object contains a pages object. The pages object, in turn, contains keys indicating the relationship of additional pages. The values of these are the URLs of the associated pages. The keys will be one of the following: * first: The URI of the first page of results. * prev: The URI of the previous sequential page of results. * next: The URI of the next sequential page of results. * last: The URI of the last page of results. The pages object will only include the links that make sense. So for the first page of results, no first or prev links will ever be set. This convention holds true in other situations where a link would not make sense. Sample Links Object Rate Limit Requests through the API are rate limited per OAuth token. Current rate limits: * 5,000 requests per hour * 250 requests per minute (5% of the hourly total) Once you exceed either limit, you will be rate limited until the next cycle starts. Space out any requests that you would otherwise issue in bursts for the best results. The rate limiting information is contained within the response headers of each request. The relevant headers are: * ratelimit-limit: The number of requests that can be made per hour. * ratelimit-remaining: The number of requests that remain before you hit your request limit. See the information below for how the request limits expire. * ratelimit-reset: This represents the time when the oldest request will expire. The value is given in Unix epoch time. See below for more information about how request limits expire. As long as the ratelimit-remaining count is above zero, you will be able to make additional requests. The way that a request expires and is removed from the current limit count is important to understand. Rather than counting all of the requests for an hour and resetting the ratelimit-remaining value at the end of the hour, each request instead has its own timer. This means that each request contributes toward the ratelimit-remaining count for one complete hour after the request is made. When that request's timer runs out, it is no longer counted towards the request limit. This has implications on the meaning of the ratelimit-reset header as well. Because the entire rate limit is not reset at one time, the value of this header is set to the time when the _oldest_ request will expire. Keep this in mind if you see your ratelimit-reset value change, but not move an entire hour into the future. If the ratelimit-remaining reaches zero, subsequent requests will receive a 429 error code until the request reset has been reached. You can see the format of the response in the examples. Note: The following endpoints have special rate limit requirements that are independent of the limits defined above. * Only 12 POST requests to the /v2/floating_ips endpoint to create Floating IPs can be made per 60 seconds. * Only 10 GET requests to the /v2/account/keys endpoint to list SSH keys can be made per 60 seconds. * Only 5 requests to any and all v2/cdn/endpoints can be made per 10 seconds. This includes v2/cdn/endpoints, v2/cdn/endpoints/$ENDPOINT_ID, and v2/cdn/endpoints/$ENDPOINT_ID/cache. * Only 50 strings within the files json struct in the v2/cdn/endpoints/$ENDPOINT_ID/cache payload can be requested every 20 seconds. Sample Rate Limit Headers Sample Rate Exceeded Response Curl Examples Throughout this document, some example API requests will be given using the curl command. This will allow us to demonstrate the various endpoints in a simple, textual format. These examples assume that you are using a Linux or macOS command line. To run these commands on a Windows machine, you can either use cmd.exe, PowerShell, or WSL: * For cmd.exe, use the set VAR=VALUE syntax to define environment variables, call them with %VAR%, then replace all backslashes (\\) in the examples with carets (^). * For PowerShell, use the $Env:VAR = \"VALUE\" syntax to define environment variables, call them with $Env:VAR, then replace curl with curl.exe and all backslashes (\\) in the examples with backticks (` `). * WSL is a compatibility layer that allows you to emulate a Linux terminal on a Windows machine. Install WSL with our community tutorial, then follow this API documentation normally. The names of account-specific references (like Droplet IDs, for instance) will be represented by variables. For instance, a Droplet ID may be represented by a variable called $DROPLET_ID. You can set the associated variables in your environment if you wish to use the examples without modification. The first variable that you should set to get started is your OAuth authorization token. The next section will go over the details of this, but you can set an environmental variable for it now. Generate a token by going to the Apps & API section of the DigitalOcean control panel. Use an existing token if you have saved one, or generate a new token with the \"Generate new token\" button. Copy the generated token and use it to set and export the TOKEN variable in your environment as the example shows. You may also wish to set some other variables now or as you go along. For example, you may wish to set the DROPLET_ID variable to one of your Droplet IDs since this will be used frequently in the API. If you are following along, make sure you use a Droplet ID that you control so that your commands will execute correctly. If you need access to the headers of a response through curl, you can pass the -i flag to display the header information along with the body. If you are only interested in the header, you can instead pass the -I flag, which will exclude the response body entirely. Set and Export your OAuth Token Set and Export a Variable Parameters There are two different ways to pass parameters in a request with the API. When passing parameters to create or update an object, parameters should be passed as a JSON object containing the appropriate attribute names and values as key-value pairs. When you use this format, you should specify that you are sending a JSON object in the header. This is done by setting the Content-Type header to application/json. This ensures that your request is interpreted correctly. When passing parameters to filter a response on GET requests, parameters can be passed using standard query attributes. In this case, the parameters would be embedded into the URI itself by appending a ? to the end of the URI and then setting each attribute with an equal sign. Attributes can be separated with a &. Tools like curl can create the appropriate URI when given parameters and values; this can also be done using the -F flag and then passing the key and value as an argument. The argument should take the form of a quoted string with the attribute being set to a value with an equal sign. Pass Parameters as a JSON Object Pass Filter Parameters as a Query String Cross Origin Resource Sharing In order to make requests to the API from other domains, the API implements Cross Origin Resource Sharing (CORS) support. CORS support is generally used to create AJAX requests outside of the domain that the request originated from. This is necessary to implement projects like control panels utilizing the API. This tells the browser that it can send requests to an outside domain. The procedure that the browser initiates in order to perform these actions (other than GET requests) begins by sending a \"preflight\" request. This sets the Origin header and uses the OPTIONS method. The server will reply back with the methods it allows and some of the limits it imposes. The client then sends the actual request if it falls within the allowed constraints. This process is usually done in the background by the browser, but you can use curl to emulate this process using the example provided. The headers that will be set to show the constraints are: * Access-Control-Allow-Origin: This is the domain that is sent by the client or browser as the origin of the request. It is set through an Origin header. * Access-Control-Allow-Methods: This specifies the allowed options for requests from that domain. This will generally be all available methods. * Access-Control-Expose-Headers: This will contain the headers that will be available to requests from the origin domain. * Access-Control-Max-Age: This is the length of time that the access is considered valid. After this expires, a new preflight should be sent. * Access-Control-Allow-Credentials: This will be set to true`. It basically allows you to send your OAuth token for authentication. You should not need to be concerned with the details of these headers, because the browser will typically do all of the work for you.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "DigitalOcean API Team",
      "documentation_url": "https://digitalocean.com",
      "version": "2.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "DigitalOcean API",
      "paths_count": 183,
      "schemas_count": 0
    }
  },
  {
    "name": "discourse_api_documentation",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/discourse.local/latest/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This page contains the documentation on how to use Discourse through API calls. Note: For any endpoints not listed you can follow the reverse engineer the Discourse API guide to figure out how to use an API endpoint. Request Content-Type The Content-Type for POST and PUT requests can be set to application/x-www-form-urlencoded, multipart/form-data, or application/json. Endpoint Names and Response Content-Type Most API endpoints provide the same content as their HTML counterparts. For example the URL /categories serves a list of categories, the /categories.json API provides the same information in JSON format. Instead of sending API requests to /categories.json you may also send them to /categories and add an Accept: application/json header to the request to get the JSON response. Sending requests with the Accept header is necessary if you want to use URLs for related endpoints returned by the API, such as pagination URLs. These URLs are returned without the .json prefix so you need to add the header in order to get the correct response format. Authentication Some endpoints do not require any authentication, pretty much anything else will require you to be authenticated. To become authenticated you will need to create an API Key from the admin panel. Once you have your API Key you can pass it in along with your API Username as an HTTP header like this: and this is how POST requests will look: Boolean values If an endpoint accepts a boolean be sure to specify it as a lowercase true or false value unless noted otherwise.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "discourse.local",
      "documentation_url": "https://discourse.local",
      "version": "latest",
      "openapi_version": "3.1.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Discourse API Documentation",
      "paths_count": 68,
      "schemas_count": 0
    }
  },
  {
    "name": "d_d_5e_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/dnd5eapi.co/0.1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Introduction Welcome to the dnd5eapi, the Dungeons & Dragons 5th Edition API! This documentation should help you familiarize yourself with the resources available and how to consume them with HTTP requests. Read through the getting started section before you dive in. Most of your problems should be solved just by reading through it. Getting Started Let's make our first API request to the D&D 5th Edition API! Open up a terminal and use curl or httpie to make an API request for a resource. You can also scroll through the definitions below and send requests directly from the endpoint documentation! For example, if you paste and run this curl command: We should see a result containing details about the Charisma ability score: Authentication The dnd5eapi is a completely open API. No authentication is required to query and get data. This also means that we've limited what you can do to just GET-ing the data. If you find a mistake in the data, feel free to message us. GraphQL This API supports GraphQL. The GraphQL URL for this API is https://www.dnd5eapi.co/graphql. Most of your questions regarding the GraphQL schema can be answered by querying the endpoint with the Apollo sandbox explorer. Schemas Definitions of all schemas will be accessible in a future update. Two of the most common schemas are described here. APIReference Represents a minimal representation of a resource. The detailed representation of the referenced resource can be retrieved by making a request to the referenced URL. DC Represents a difficulty check. Damage Represents damage. Choice Represents a choice made by a player. Commonly seen related to decisions made during character creation or combat (e.g.: the description of the cleric class, under Proficiencies, states \"Skills: Choose two from History, Insight, Medicine, Persuasion, and Religion\" [[SRD p15]](https://media.wizards.com/2016/downloads/DND/SRD-OGL_V5.1.pdf#page=15)) OptionSet The OptionSet structure provides the options to be chosen from, or sufficient data to fetch and interpret the options. All OptionSets have an option_set_type attribute that indicates the structure of the object that contains the options. The possible values are options_array, equipment_category, and reference_list. Other attributes on the OptionSet depend on the value of this attribute. - options_array - options (array): An array of Option objects. Each item in the array represents an option that can be chosen. - equipment_category - equipment_category (APIReference): A reference to an EquipmentCategory. Each item in the EquipmentCategory's equipment array represents one option that can be chosen. - resource_list - resource_list_url (string): A reference (by URL) to a collection in the database. The URL may include query parameters. Each item in the resulting ResourceList's results array represents one option that can be chosen. Option When the options are given in an options_array, each item in the array inherits from the Option structure. All Options have an option_type attribute that indicates the structure of the option. The value of this attribute indicates how the option should be handled, and each type has different attributes. The possible values and their corresponding attributes are listed below. - reference - A terminal option. Contains a reference to a Document that can be added to the list of options chosen. - item (APIReference): A reference to the chosen item. - action - A terminal option. Contains information describing an action, for use within Multiattack actions. - action_name (string): The name of the action, according to its name attribute. - count (number | string): The number of times this action can be repeated if this option is chosen. - type (string = \"melee\" | \"ranged\" | \"ability\" | \"magic\", optional): For attack actions that can be either melee, ranged, abilities, or magic. - multiple - When this option is chosen, all of its child options are chosen, and must be resolved the same way as a normal option. - items (array): An array of Option objects. All of them must be taken if the option is chosen. - choice - A nested choice. If this option is chosen, the Choice structure contained within must be resolved like a normal Choice structure, and the results are the chosen options. - choice (Choice): The Choice to resolve. - string - A terminal option. Contains a reference to a string. - string (string): The string. - ideal - A terminal option. Contains information about an ideal. - desc (string): A description of the ideal. - alignments (ApiReference[]): A list of alignments of those who might follow the ideal. - counted_reference - A terminal option. Contains a reference to something else in the API along with a count. - count (number): Count. - of (ApiReference): Thing being referenced. - score_prerequisite - A terminal option. Contains a reference to an ability score and a minimum score. - ability_score (ApiReference): Ability score being referenced. - minimum_score (number): The minimum score required to satisfy the prerequisite. - ability_bonus - A terminal option. Contains a reference to an ability score and a bonus - ability_score (ApiReference): Ability score being referenced - bonus (number): The bonus being applied to the ability score - breath - A terminal option: Contains a reference to information about a breath attack. - name (string): Name of the breath. - dc (DC): Difficulty check of the breath attack. - damage ([Damage]): Damage dealt by the breath attack, if any. - damage - A terminal option. Contains information about damage. - damage_type (ApiReference): Reference to type of damage. - damage_dice (string): Damage expressed in dice (e.g. \"13d6\"). - notes (string): Information regarding the damage. FAQ What is the SRD? The SRD, or Systems Reference Document, contains guidelines for publishing content under the OGL. This allows for some of the data for D&D 5e to be open source. The API only covers data that can be found in the SRD. Here's a link to the full text of the SRD. What is the OGL? The Open Game License (OGL) is a public copyright license by Wizards of the Coast that may be used by tabletop role-playing game developers to grant permission to modify, copy, and redistribute some of the content designed for their games, notably game mechanics. However, they must share-alike copies and derivative works. More information about the OGL can be found here. A monster, spell, subclass, etc. is missing from the API / Database. Can I add it? Please check if the data is within the SRD. If it is, feel free to open an issue or PR to add it yourself. Otherwise, due to legal reasons, we cannot add it. Can this API be self hosted? Yes it can! You can also host the data yourself if you don't want to use the API at all. You can also make changes and add extra data if you like. However, it is up to you to merge in new changes to the data and API. Can I publish is on ? Is this free use? Yes, you can. The API itself is under the MIT license, and the underlying data accessible via the API is supported under the SRD and OGL. Status Page The status page for the API can be found here: https://5e-bits.github.io/dnd-uptime/ Chat Come hang out with us on Discord! Contribute This API is built from two repositories. - The repo containing the data lives here: https://github.com/bagelbits/5e-database - The repo with the API implementation lives here: https://github.com/bagelbits/5e-srd-api This is a evolving API and having fresh ideas are always welcome! You can open an issue in either repo, open a PR for changes, or just discuss with other users in this discord.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "5eBits",
      "documentation_url": "https://github.com/5e-bits",
      "version": "0.1",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "D&D 5e API",
      "paths_count": 47,
      "schemas_count": 49
    }
  },
  {
    "name": "docusign_rest_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/docusign.net/v2.1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "DocuSign Developer Center",
      "documentation_url": "https://docs.docusign.com/esign",
      "version": "v2.1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "DocuSign REST API",
      "paths_count": 208,
      "schemas_count": 580
    }
  },
  {
    "name": "nookipedia",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/dodo.ac/1.6.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The Nookipedia API provides endpoints for retrieving Animal Crossing data pulled from the Nookipedia wiki. A couple of the key benefits of using the Nookipedia API is access to data spanning the entire Animal Crossing series, as well as information that is constantly updated and expanding as editors work on the wiki.Access to the Nookipedia API requires obtaining a key. This is so we can manage our scale and provide better support for our users. To request access to the API, please fill out this form.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "dodo.ac",
      "documentation_url": "https://dodo.ac",
      "version": "1.6.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Nookipedia",
      "paths_count": 30,
      "schemas_count": 21
    }
  },
  {
    "name": "dracoon_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/dracoon.team/4.42.3/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "REST Web Services for DRACOONThis page provides an overview of all available and documented DRACOON APIs, which are grouped by tags.Each tag provides a collection of APIs that are intended for a specific area of the DRACOON.Developer Information&emsp;&emsp;Get SDKs on GitHubTerms of service",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "dracoon.team",
      "documentation_url": "https://dracoon.team",
      "version": "4.42.3",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "DRACOON API",
      "paths_count": 181,
      "schemas_count": 282
    }
  },
  {
    "name": "visma_e_conomic_openapi",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/e-conomic.com/v20.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Changelog Click to see changelog. | Version | Description | |---------| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | 20.0.0 | Customer contacts and delivery locations endpoints deprecated. You can find the same enpoints in Customers API | 19.0.0 | Page-based endpoints were moved under /paged url and cursor-based endpoints dropped the /all. | 18.0.0 | Added isDeleted flag to customer-contacts and included deleted contacts in the response. Deleted contacts can be used for history purposes, but cannot be set as reference persons on sales documents. In previous versions only customer-contacts/id returns deleted contacts as well. | 17.0.2 | TimeEntryEmployeeNumberCannotBeUpdated and MileageEmployeeNumberCannotBeUpdated error codes removed. The change affects all versions, but we bumped the version for transparency. | 17.0.1 | New custom OpenAPI extension added in the specification: x-error-codes. Existing x-required-roles extension converted to an array of strings. | 17.0.0 | Improved the error model. Added code and property fields to the model. code represents the error code. property is the field name on which the input validation failed. | 16.4.0 | customer-deliverylocations endpoints added. | 16.3.0 | customer-contacts endpoints added. | 16.2.2 | Added input validations for required string properties, if a string property is required it can't be empty, it should contain at least 1 character. | 16.2.1 | Error codes extended for mileages and timeentries. Affects all the exisiting versions. | 16.2.0 | - employeegroups DELETE endpoint added. - employees DELETE endpoint added. - project-employeegroups DELETE endpoint added. - project-employees DELETE endpoint added. | 16.1.0 | Time entry prices and Mileage entry prices endpoints added. | 16.0.0 | Changed parameter schema for mileages and timeentries approve endpoints. | 15.0.0 | Added cost and sales accounts properties in activitygroups endpoints. | 14.1.3 | - Added new filter for IsAccessible in activities endpoints. - Added new filter for IsBarred in costtypes endpoints. | 14.1.2 | - Added input validations for activitygroups. - Updated description for projectgroups properties. | 14.1.1 | Added input validations for projectgroups. | 14.1.0 | project-employees-count endpoint added. | 14.0.0 | - project-activities endpoints added. - projects/activities have been deprecated.| | 13.2.0 | costtypegroups endpoints added.| | 13.1.0 | costtypes endpoints added.| | 13.0.0 | - projectgroups POST endpoint added, Number made non-required,- activitygroups POST endpoint added, Number made non-required.| | 12.0.0 | projects Number made non-required. | | 11.0.0 | employees Number made required. | | 10.1.2 | API version number moved to the server URL. | | 10.1.1 | - activities employeeNumber maximum value changed to 999999. - projects employeeNumber maximum value changed to 999999. | | 10.1.0 | project-employees POST endpoint added. | | 10.0.0 | - activities POST and PUT endpoints added. - activitygroups GET endpoints added. - Object version field added to activities, projectstatuses and projectgroups endpoints. | | 9.0.0 | Project related settings for employee resource renamed as Project employee. | | 8.1.0 | project-customers endpoints added. | | 8.0.0 | - employeegroups endpoints added: GET all paginated, GET count, POST and PUT. - project-employeegroups endpoints added: GET all paginated, GET all cursor-based, GET count, GET by number, POST and PUT. - Object version field added to employee groups endpoints. | | | 7.0.0 | Projects related settings for employee extended with new fields for Name, GroupNumber and IsBarred. | | 6.0.0 | Readonly property IsReconciled added to TimeEntries endpoint. | | 5.1.0 | Project delete endpoint added. | | 5.0.0 | - Project-related properties such as isUser, userId, canApprove, canInvoice, employeeType in /employees moved to /project-employees. - Properties lastUpdated, costPrice, salesPrice and invoicedtotal in /projects changed to readonly.- Property date in /timeentries changed to mandatory.- Access permission to /employees changed to requiring access to Sales.- PUT endpoints for /timeentries/{number}, /employees/{number}, /employeeprojectrelatedsettings/{number} have been deprecated and new ones without {number} in the URL have been added. | | 4.0.0 | project.CustomerNumber made non-required, range check introduced. | | 3.1.0 | Error messages of time entry approval improved, timeEntry.IsApproved, mileage.IsApproved and mileage.IncludeApproval made read-only. | | 3.0.0 | mileage.Date made required. Verification for mileage.EmployeeNumber and mileage.Distance added. | | 2.2.2 | Range check introduced in projects.Number, employee.Number and employeeGroup.Number. | | 2.2.1 | Employees PATCH endpoint deprecated. | | 2.2.0 | employeegroups/all and employeegroups/{number} endpoints added. | | 2.1.0 | /activities/allowed endpoint added to get allowed activities for an employee and project. | | 2.0.0 | Open API released! Endpoints related to Projects module added. | TL;DR Add these three headers to your requests. | Header | Value | What is this? | | :-------------------- | :------------------------- | :----------------------------------------------------------- | | X-AppSecretToken | YOUR_PRIVATE_TOKEN | This identifies your app. This is your secret token. Try using the value demo. | | X-AgreementGrantToken | YOUR_AGREEMENT_GRANT_TOKEN | This identifies the grant issued by an agreement, to allow your app to access the agreements data. Try using the value demo. | | Content-Type | application/json | We’re a JSON based API. This tells us that you agree with us on using JSON. | Examples jQuery cURL Introduction Welcome to the Visma e-conomic OpenAPI documentation! The e-conomic API is a document-based JSON REST API. For more in-depth information about e-conomic itself, please have a look at the e-copedia http://wiki.e-conomic.dk. Usage - Generating a client can easily be done using tools like swagger-codegen or others that work with OpenAPI Specification specs. Versioning API releases are versioned using a three-part versioning scheme: {major version}.{minor version}.{patch version}. We broadly follow Semantic Versioning principles when versioning the API. The major version number is incremented when a breaking change occurs. The format is: /api/v{major version}.{minor version}.{patch version}/{resource-name} Each value of the above are integers and you should configure the specific version in each API call. An example could be: /api/v2.2.1/projects To track the changes of versions, please see our changelog. We reserve the right to deprecate versions at intervals since this allows for moving into a friendly environment for you faster. Demo authentication If you wish to try out the API before registering a developer agreement, you can do this by using the demo agreement, which mimics the authentication flow you will have to use when you create your app. All you have to do is specify HTTP header tokens X-AgreementGrantToken: demo and X-AppSecretToken: demo. Note however that you can only do GET requests with the demo agreement. If you want full access to our API's, you will need to register. Retrieving data Our data is exposed as collections of items. Each item has many properties, with one property as a unique identifier, usually called number or id. You can always get a single item if you already know the unique identifier. In case the unique identifier is not known, you can always search the collection and retrieve an array of items that satisfy the search criteria, or retrieve only the count of items that satisfy the search criteria. When you search for items in a collection, you can always use filtering, sorting and pagination. When it comes to pagination, we offer two distinct approaches available on separate endpoints. You can read more about filtering, sorting and pagination in the following sections. Filtering Filtering is enabled on all collection endpoints but not on all properties. Filtering on collections can be done using the query string parameter filter. A filter is made up of a set of predicates and follows a syntax inspired by mongoDB. A predicate is made up of a property name, an operator, and a value. Example: ?filter=name$eq:Joe This matches all resources with the value Joe in the property name. Predicates can be chained using either of the logical operators AND and OR. Example: ?filter=name$eq:Joe$and:city$like:*port Filtering on strings is case insensitive. Filterable properties Information about what properties allow filtering and on what operators can be found in the property in the schema for the collection. Each property that allows filtering has the property \"x-filterable\" in combination with operators set. If you try to filter on something that isn’t allowed the server will respond with a status code 400. Specifying Operator affinity If you want to control the operator affinity then you can use parentheses. An example is: ?filter=name$eq:Joe$and:(city$like:*port$or:age$lt:40) URL Encoding URL parameter values should always be URL compatible. Always URL encode filter strings. Filter Operators The possible filtering operators are: | Operator | Syntax | | -------- | ------ | |Equals | $eq:| |Not equals | $ne:| |Greater than | $gt:| |Greater than or equal | $gte:| |Less than | $lt:| |Less than or equal | $lte:| |Substring match | $like:| |And also | $and:| |Or else | $or:| |In | $in:| |Not In | $nin:| Substring matching The $like: operator supports both using wildcards (*) and not using wildcards. If no wildcards are used, the expression is considered a contains expression and effectively becomes a filter with a wildcard at the start of the string and one at the end of the string. This operator is only allowed on some properties. Escaping special characters in your filter To not interfere with the parsing of the filter expression, certain escape sequences are necessary. - “$” is escaped with “$$” - “(” is escaped with “$(” - “)” is escaped with “$)” - “” is escaped with “$” - “,” is escaped with “$,” - “[” is escaped with “$[” - “]” is escaped with “$]” Using null values in your filter Should you want to filter for the nonexistence of a property (i.e. null value) you can use the null escape sequence. $null: Using in and not in operators To determine whether a specified value matches any value in (or not in) a list you filter using the $in: or $nin: operator. The list to filter by has to be enclosed in brackets and values separated by commas. customerNumber$in:[2,5,7,22,45] It is possible to also use the $null: keyword if you wish to include that in the filter. The max supported length of an array using the $in: or $nin: operator is 200. Sorting Sorting on strings is case insensitive. Sort ascending Sorting on collections can be done using the query string parameter ‘sort’. Sort descending The default sort direction is ascending, but this can be turned by prepending a minus (-). Sort by multiple properties If you need to sort by multiple properties these can just be separated by commas. Mixing of directions is allowed. Sort alphabetically In certain cases, you might want to enforce that even numeric values are sorted alphabetically, so 1000 is less than 30. In those cases, you can prepend the sort property with a tilde (~). Sortable properties Information about what properties are sortable can be found in the schema for the collection. Each property that allows sorting has the property \"x-sortable\": true set. Pagination When it comes to retrieving a collection of items, you can use two distinct approaches: * Cursor-based pagination (continued loading of items using a cursor as a query parameter to get the next page of items) * This is the recommended approach, and the one you should use by default. * The endpoint naming scheme is \"Retrieve all Items\". (Usage: /{ITEM}?cursor={CURSOR_VALUE}) Classic pagination (limited functionality. Specify skippages and pagesize as query parameters to get a specific page of items) * You should only consider using classic pagination, if you rely on loading pages (i.e. for list views or table/grid-based UI's). * The endpoint naming scheme is \"Retrieve a page of Items\". (Usage: /{ITEM}/paged?skippages=0&pagesize=20) \\* It's important to note that there is a limit of 10.000 items using this approach. Any items outside of the first 10.000 items will not be loaded. Please bear in mind that the two approaches are supported by separate endpoints. To use classic pagination, add /paged to your request URL. If you need to know the total count of items that you can expect to get from your search, you can use a separate endpoint called \"Retrieve the number of Items\". You can also use the result of this endpoint to calculate the pagination navigation buttons for a table/grid-based UI. Which approach should you use? We highly recommend that you use cursor-based pagination because: - It is more performant and offers much faster retrieval of items; - It can be used for very large collections of many thousands or millions of items, whereas classic pagination is limited to only returning 10.000 results, everything else is ignored; Classic pagination is only appropriate when you have an app with a table/grid-based UI. Cursor-based pagination How it works When you search for items in a large collection, the response will contain the first 1.000 items and a cursor that you can use in a subsequent request to get the next series of items. This way you can retrieve the next set of items only when needed (if 1.000 items suffice, you don't need to send a second request). Please note that the cursor is currently the id of the first item on the next set and it should not be mistaken for the number of items which are yet to be displayed. Also, if the cursor is not present in the response, it means that there are no more items in the results. Real world example I want to retrieve all projects. 1) I send a request to https://apis.e-conomic.com/api/v20.0.0/projects and get back an array of 1.000 projects, and a cursor with value 34781 2) I send a request for the next items in the resulting collection: https://apis.e-conomic.com/api/v20.0.0/projects?cursor=34781 and get back an array of 1.000 projects and a cursor with value 87695 3) I send a request for the next items in the result: https://apis.e-conomic.com/api/v20.0.0/projects?cursor=87695 and get back an array of 56 items and no cursor. No cursor means I have retrieved all the projects, i.e. I have reached the end of the list. Classic pagination If no parameters are used, the collection endpoint returns 20 items at a time. URL parameters allow you to increase this to up to 100 items or to skip pages if necessary. Real world example I want to show a grid with page size of 50 and pagination navigation buttons. 1) I send a request to see how many projects there are in the collection: https://apis.e-conomic.com/api/v20.0.0/projects/count I get the number of projects in the collection, 2056, and I can calculate the number of pages to be 2056 divided by 50 = 40 with 6 as remainder, meaning I have 41 pages total. I can then use this to present the user the navigation buttons. 2) I send a request to retrieve the first page of projects that my user will see: https://apis.e-conomic.com/api/v20.0.0/projects/paged?pagesize=50&sort=name with this I get back an array of 50 projects, sorted alphabetically by the project name. 3) Now if the user wants to see page number 6, I'll send a new request, skipping the first 5 pages to get the projects from page number 6: https://apis.e-conomic.com/api/v20.0.0/projects/paged?pagesize=50&skippages=5&sort=name I get back an array of 50 projects, that belong to page number 6 when sorting alphabetically by the project name. Number of items in a collection As mentioned before we offer endpoint to get the count of items in the collection. You can also use this info for calculation of pagination navigation in case of classic pagination. Example https://apis.e-conomic.com/api/v20.0.0/projects/count HTTP Status Codes The Open API returns these HTTP status codes. | Code | Text | Description | | :--- | :--------------------- | :----------------------------------------------------------- | | 200 | OK | Everything is OK | | 201 | Created | When you create resources, this is what you get. This will be accompanied by the created resource in the body and a location header with a link to the created resource. | | 204 | No Content | In certain cases there is nothing to return. So we will let you know by returning a 204. | | 400 | Bad Request | The request you made was somehow malformed. A malformed request could be failed validation on creation or updating. If you try to filter on something that isn’t filterable this is also what you’ll see. Whenever possible we will also try to include a developer hint to help you get around this issue. | | 401 | Unauthorized | The credentials you supplied us with weren’t correct, or perhaps you forgot them altogether. If an agreement has revoked the grant they gave your app, this is what you will see. | | 403 | Forbidden | You won’t necessarily have access to everything. So even though you were authorized we might still deny access to certain resources. This depends on the roles asked for when the grant was issued. | | 404 | Not Found | This is returned when you try to request something that doesn’t exist. This could be a resource that has been deleted or just a URL you tried to hack. If you see a lot of these, it could be an indication that you aren’t using the links provided by the API. You should never need to concatenate any URLs. The API should provide you with the links needed. | | 405 | Method Not Allowed | Not all endpoints support all HTTP methods. If you try issue a PUT request to a collection resource this is what you get. | | 415 | Unsupported Media Type | Our API is a JSON api. If you ask us to give you anything else, we give you this, and tell you why in the JSON body of the response. | | 500 | Internal Server Error | We don’t like to see these, and they are flagged in our logs. When you see this, something went wrong on our end. Either try again, or contact our support. | Required and Readonly Properties Since OpenAPI allows client generation based on the specification, we decided to use the same model/schema in our for both read and write endpoints where possible. This led us to chose not to have the Id/Number in the URL parameter for PUT requests, but to use the one from the body, so there is no confusion. When a property is marked as required it means you need to provide a value on each POST and PUT requests. When a property is marked as readonly it means you should provide the same value you get in the GET requests, or do not send the property in the JSON at all (skip it). Custom resource encoding For some resource ids (the direct URL path to a resource) the question of non-alphanumeric characters must be solved in REST APIs by either encoding or replacement to ensure URL compatibility. In the e-conomic REST API a subset of non-alphanumeric characters are replaced using a custom scheme for resource URLs: | Character | Replacement | | :--------------- | :---------- | | “” | 1 | | “” | 2* | | “%” | 3 | | “:” | 4 | | “&” | 5 | | “/” | 6 | | “\\” | 7 | | “_” | 8 | | “ ” (whitespace) | 9 | | “?” | 10 | | “.” | 11 | | “#” | 12 | | “+” | 13 | Example: Product “My Awesome Product_Discount5%” Resource URL (self): https://apis.e-conomic.com/products/My_9_Awesome_9_Product_8_Discount5_3_ All other non-alphanumeric characters in resource URLs are standard URL encoded. Please refer to standard URL encoding for characters not mentioned above. Implementation specifics Helpful details to know when implementing e-conomic REST. Booleans Booleans should only be expected to be represented in responses when true. A false boolean is omitted from response body. The same logic applies to write operations such as POST and PUT. Null values Null values are omitted from the response body. Nulling We do not generally accept null as a value and a validation exception should be expected. To null a property you must exclude it from your JSON on the write operation. Object version ObjectVersion is the mechanism that enforces updates only on latest state of an object. ObjectVersion property is mandatory in Put Requests. ObjectVersion property is retrieved on Get Request and needs to be included in Put Request. If object was modified between Get and Put requests, Put request will fail with error code 409 Conflict Custom extensions in OpenAPI specification In the specification file, there are some custom extensions that developers can make use of when consuming endpoints. Those extensions are always prefixed by x-. 1) x-required-roles: The list of roles that are required for each group of endpoints. 2) x-error-codes: The list of error codes that are potentially returned from each group of endpoints.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "e-conomic.com",
      "documentation_url": "https://www.e-conomic.com/",
      "version": "v20.0.0",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "Visma e-conomic OpenAPI",
      "paths_count": 70,
      "schemas_count": 44
    }
  },
  {
    "name": "elmah_io_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/elmah.io/v3/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is the public REST API for elmah.io. All of the integrations communicates with elmah.io through this API.For additional help getting started with the API, visit the following help articles:Using the REST APIWhere is my API key?Where is my log ID?How to configure API key permissions",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "elmah.io",
      "documentation_url": "https://elmah.io",
      "version": "v3",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "elmah.io API",
      "paths_count": 16,
      "schemas_count": 17
    }
  },
  {
    "name": "api_v1_0_0",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/envoice.in/v1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "![Run in Postman](https://app.getpostman.com/run-collection/80638214aa04722c9203) or View Postman docs Quickstart Visit github to view the quickstart tutorial. Tutorial for running the API in postman Click on \"\"Run in Postman\"\" button !postman - tutorial - 1 --- A new page will open. Click the \"\"Postman for windows\"\" to run postman as a desktop app. Make sure you have already installed Postman. !postman - tutorial - 2 --- In chrome an alert might show up to set a default app for opening postman links. Click on \"\"Open Postman\"\". !postman - tutorial - 3 --- The OpenAPI specification will be imported in Postman as a new collection named \"\"Envoice api\"\" !postman - tutorial - 4 --- When testing be sure to check and modify the environment variables to suit your api key and secret. The domain is set to envoice's endpoint so you don't really need to change that. \\*Eye button in top right corner !postman - tutorial - 5 !postman - tutorial - 6 --- You don't need to change the values of the header parameters, because they will be replaced automatically when you send a request with real values from the environment configured in the previous step. !postman - tutorial - 7 --- Modify the example data to suit your needs and send a request. !postman - tutorial - 8 Webhooks Webhooks allow you to build or set up Envoice Apps which subscribe to invoice activities. When one of those events is triggered, we'll send a HTTP POST payload to the webhook's configured URL. Webhooks can be used to update an external invoice data storage. In order to use webhooks visit this link and add upto 10 webhook urls that will return status 200 in order to signal that the webhook is working. All nonworking webhooks will be ignored after a certain period of time and several retry attempts. If after several attempts the webhook starts to work, we will send you all activities, both past and present, in chronological order. The payload of the webhook is in format:",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "envoice.in",
      "documentation_url": "https://envoice.in",
      "version": "v1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "API v1.0.0",
      "paths_count": 61,
      "schemas_count": 110
    }
  },
  {
    "name": "etherpad_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/etherpad.local/1.2.15/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Etherpad is a real-time collaborative editor scalable to thousands of simultaneous real time users. It provides full data export capabilities, and runs on your server, under your control.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "The Etherpad Foundation",
      "documentation_url": "https://etherpad.org/",
      "version": "1.2.15",
      "openapi_version": "3.0.2",
      "quality_score": 100,
      "is_popular": false,
      "title": "Etherpad API",
      "paths_count": 48,
      "schemas_count": 3
    }
  },
  {
    "name": "exavault",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/exavault.com/2.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "ExaVaults API allows you to incorporate ExaVaults suite of file transfer and user management tools into your own application.\\nExaVault supports both POST (recommended when requesting large data sets) and GET operations, and requires an API key in order to use.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "ExaVault Support",
      "documentation_url": "https://www.exavault.com/developer/",
      "version": "2.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "ExaVault",
      "paths_count": 35,
      "schemas_count": 65
    }
  },
  {
    "name": "openfec",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/fec.gov/1.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This application programming interface (API) allows you to explore the way candidates and committees fund their campaigns. The Federal Election Commission (FEC) API is a RESTful web service supporting full-text and field-specific searches on FEC data. Bulk downloads are available on the current site. Information is tied to the underlying forms by file ID and image ID. Data is updated nightly. There are a lot of data, and a good place to start is to use search to find interesting candidates and committees. Then, you can use their IDs to find report or line item details with the other endpoints. If you are interested in individual donors, check out contributor information in the /schedule_a/ endpoints. Getting started with the openFEC API If you would like to use the FEC's API programmatically, you can sign up for your own API key using our form. Alternatively, you can still try out our API without an API key by using the web interface and using DEMO_KEY. Note that when you use the openFEC API you are subject to the Terms of Service and Acceptable Use policy. Signing up for an API key will enable you to place up to 1,000 calls an hour. Each call is limited to 100 results per page. You can email questions, comments or a request to get a key for 7,200 calls an hour (120 calls per minute) to APIinfo@fec.gov. You can also ask questions and discuss the data in a community led group. The model definitions and schema are available at /swagger. This is useful for making wrappers and exploring the data. A few restrictions limit the way you can use FEC data. For example, you can’t use contributor lists for commercial purposes or to solicit donations. Learn more here. Inspect our source code. We welcome issues and pull requests! Sign up for an API key Loading signup form...",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "fec.gov",
      "documentation_url": "https://fec.gov",
      "version": "1.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "OpenFEC",
      "paths_count": 92,
      "schemas_count": 172
    }
  },
  {
    "name": "flat_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/flat.io/2.13.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The Flat API allows you to easily extend the abilities of the Flat Platform, with a wide range of use cases including the following: * Creating and importing new music scores using MusicXML, MIDI, Guitar Pro (GP3, GP4, GP5, GPX, GP), PowerTab, TuxGuitar and MuseScore files * Browsing, updating, copying, exporting the user's scores (for example in MP3, WAV or MIDI) * Managing educational resources with Flat for Education: creating & updating the organization accounts, the classes, rosters and assignments. The Flat API is built on HTTP. Our API is RESTful It has predictable resource URLs. It returns HTTP response codes to indicate errors. It also accepts and returns JSON in the HTTP body. The schema of this API follows the OpenAPI Initiative (OAI) specification, you can use and work with compatible Swagger tools. This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with W3C spec. You can use your favorite HTTP/REST library for your programming language to use Flat's API. This specification and reference is available on Github. Getting Started and learn more: * API Overview and introduction * Authentication (Personal Access Tokens or OAuth2) * SDKs * Rate Limits * Changelog",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Flat",
      "documentation_url": "https://flat.io/developers/docs/api/",
      "version": "2.13.0",
      "openapi_version": "3.0.2",
      "quality_score": 100,
      "is_popular": false,
      "title": "Flat API",
      "paths_count": 51,
      "schemas_count": 76
    }
  },
  {
    "name": "flickr_api_schema",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/flickr.com/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "A subset of Flickr's API defined in Swagger format.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "flickr.com",
      "documentation_url": "https://flickr.com",
      "version": "1.0.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Flickr API Schema",
      "paths_count": 25,
      "schemas_count": 16
    }
  },
  {
    "name": "frankie_financial_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/frankiefinancial.io/1.5.3/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "------ This API allows developers to integrate the Frankie Financial Compliance Utility into their applications. The API allows: - Checking name, address, date of birth against national databases - Validating Australian driver's licences, passports, medicare, visas and other Australian national ID documents - Validating Australian electricity bills - Validating NZ driver's licences - Validating Chinese bank cards and national ID card - Validating International passports and national ID documents - PEP, Sanctions, Watchlist and adverse media checking - Australian visa checks - Fraud list and fraud background checks - ID validation and selfie check comparisons. ------ Industry specific services - Comparing Australian electricity retailers for a better deal. ------ KYB specific services - Query organisation ownership - Perform KYC & AML checks on shareholders, beneficial owners and office bearers. - Query credit score and credit reports - International company searches - International company profiles ------ The full version of this documentation along with supplemental articles can be found here: - https://apidocs.frankiefinancial.com/ The traditional Swagger view of this documentation can be found here: - https://app.swaggerhub.com/apis-docs/FrankieFinancial/kycutility ------ Sandbox base URL is: - https://api.demo.frankiefinancial.io/compliance/v1.2 - We do have an old sandbox at https://sandbox.frankiefinancial.com/compliance/v1.2 but this has been retired. - All calls are the same as production, only with canned data. - Full Swagger definition, along with test data for playing in the sandbox can be obtained once initial commercial discussions have commenced. - Production and optional UAT access will be opened up only to those with a signed commercial contract. ------ Contact us at hello@frankiefinancial.com to speak with a sales rep about issuing a Customer ID and Sandbox api key.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "frankiefinancial.io",
      "documentation_url": "https://frankiefinancial.io",
      "version": "1.5.3",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Frankie Financial API",
      "paths_count": 42,
      "schemas_count": 174
    }
  },
  {
    "name": "gerermesaffaires_rest_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/gerermesaffaires.com/1.0.6/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Sécurisez vos données en interfaçant votre logiciel métier avec le service en ligne GererMesAffaires",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "gerermesaffaires.com",
      "documentation_url": "https://api.gerermesaffaires.com/",
      "version": "1.0.6",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "GererMesAffaires {REST:API}",
      "paths_count": 180,
      "schemas_count": 53
    }
  },
  {
    "name": "gitea_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/gitea.io/1.20.0+dev-539-g5e389228f/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This documentation describes the Gitea API.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "gitea.io",
      "documentation_url": "https://gitea.io",
      "version": "1.20.0+dev-539-g5e389228f",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Gitea API.",
      "paths_count": 217,
      "schemas_count": 171
    }
  },
  {
    "name": "eqivo_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/github.com/v0.1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Eqivo OpenApi Specification",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "github.com",
      "documentation_url": "https://github.com",
      "version": "v0.1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": true,
      "title": "Eqivo API",
      "paths_count": 29,
      "schemas_count": 59
    }
  },
  {
    "name": "travel_partner_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/google.com/v3/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The Travel Partner API provides you with a RESTful interface to the Google Hotel Center platform. It enables an app to efficiently retrieve and change Hotel Center data, and is thus suitable for managing large or complex accounts.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Google",
      "documentation_url": "https://developers.google.com/hotels/hotel-prices/api-reference",
      "version": "v3",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Travel Partner API",
      "paths_count": 17,
      "schemas_count": 52
    }
  },
  {
    "name": "google_home",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/google.home/2.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Google Home Local API This is an unofficial documentation of the local API used by the Home app to communicate with GH devices. GitHub Repo ![GitHub stars](https://github.com/rithvikvibhu/GHLocalApi/stargazers) ![GitHub license](https://github.com/rithvikvibhu/GHLocalApi/blob/master/LICENSE.md) Getting Started Requests must be made over HTTPS, port 8443, so the base URL for these endpoints is: https://:8443/setup/ Get the IP of Google Home from the Google Home app (Device Settings -> End of the list) or from your router. GET requests are simple, in the browser kind. POST requests need to set the header (when there's a body): content-type: application/json Authentication Since June 2019, most requests (with exceptions like /setup/eureka_info) need a local authorization token. There are 3 kinds of tokens involved here: Local Authorization Token This token must be sent in all requests in the header cast-local-authorization-token. It is short-lived (~1 day) and may change unexpectedly (with a sync, change in homegraph, etc.) Get this token - With access to an android device, get this token directly by either method. - Without a device, or to integrate it with a script, use an access token to get the homegraph and extract the token. To get an access token, read the next section. Check the example section for more info. Access Token This is a standard google oauth2 access token. It is in the form ya29.*. This gives access to the Google Home Foyer API. These expire in an hour. Use this to get the homegraph (and then the local authorization token above). Get this token To get this access token, either a Google account username/password or a Google Master Token is needed. More info in the gist. Use the script from this gist. Master Token This is in the form aas_et/* and can be used to request access tokens. Get this token The same script in the gist that gets the access token can also get the master token. Needs Google account creds. Example Here's the whole flow from just a pair of username/password to using the local API. Prerequisites: - grpcurl - Proto files (preserve folder structure) 1. Get an access token with the script - Download get_tokens.py - Fill in username and password 2. Use the access token and get home graph - This prints the json and uses jq to parse and filter out the fields deviceName and localAuthToken - This will give a list of all devices and their local auth tokens 3. Make the call to the local device using the local auth token",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "google.home",
      "documentation_url": "https://google.home",
      "version": "2.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Google Home",
      "paths_count": 30,
      "schemas_count": 70
    }
  },
  {
    "name": "graphhopper_directions_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/graphhopper.com/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "With the GraphHopper Directions API you can integrate A-to-B route planning, turn-by-turn navigation, route optimization, isochrone calculations and other tools in your application. The GraphHopper Directions API consists of the following RESTful web services: * Routing API, * Route Optimization API, * Isochrone API, * Map Matching API, * Matrix API, * Geocoding API and * Cluster API. Explore our APIs Get started 1. Sign up for GraphHopper 2. Create an API key Each API part has its own documentation. Jump to the desired API part and learn about the API through the given examples and tutorials. In addition, for each API there are specific sample requests that you can send via Insomnia or Postman to see what the requests and responses look like. Insomnia To explore our APIs with Insomnia, follow these steps: 1. Open Insomnia and Import our workspace. 2. Specify your API key in your workspace: Manage Environments -> Base Environment -> \"api_key\": your API key 3. Start exploring !Insomnia Postman To explore our APIs with Postman, follow these steps: 1. Import our request collections as well as our environment file. 2. Specify your API key in your environment: \"api_key\": your API key 3. Start exploring !Postman API Client Libraries To speed up development and make coding easier, we offer the following client libraries: * JavaScript client - try the live examples * Others like C#, Ruby, PHP, Python, ... automatically created for the Route Optimization API Bandwidth reduction If you create your own client, make sure it supports http/2 and gzipped responses for best speed. If you use the Matrix, the Route Optimization API or the Cluster API and want to solve large problems, we recommend you to reduce bandwidth by compressing your POST request and specifying the header as follows: Content-Encoding: gzip. This will also avoid the HTTP 413 error \"Request Entity Too Large\". Contact Us If you have problems or questions, please read the following information: - FAQ - Public forum - Contact us - GraphHopper Status Page To stay informed about the latest developments, you can - follow us on twitter, - read our blog, - watch our documentation repository, - sign up for our newsletter or - our forum. Select the channel you like the most. Map Data and Routing Profiles Currently, our main data source is OpenStreetMap. We also integrated other network data providers. This chapter gives an overview about the options you have. OpenStreetMap Geographical Coverage OpenStreetMap covers the whole world. If you want to see for yourself if we can provide data suitable for your region, please visit GraphHopper Maps. You can edit and modify OpenStreetMap data if you find that important information is missing, e.g. a weight limit for a bridge. Here is a beginner's guide that shows how to add data. If you have edited data, we usually consider your data after 1 week at the latest. Supported Vehicle Profiles The Routing, Matrix and Route Optimization APIs support the following vehicle profiles: Name | Description | Restrictions | Icon -----------|:----------------------|:--------------------------|:--------------------------------------------------------- car | Car mode | car access | !car image small_truck| Small truck like a Mercedes Sprinter, Ford Transit or Iveco Daily | height=2.7m, width=2+0.4m, length=5.5m, weight=2080+1400 kg | !small truck image truck | Truck like a MAN or Mercedes-Benz Actros | height=3.7m, width=2.6+0.5m, length=12m, weight=13000 + 13000 kg, hgv=yes, 3 Axes | !truck image scooter | Moped mode | Fast inner city, often used for food delivery, is able to ignore certain bollards, maximum speed of roughly 50km/h | !scooter image foot | Pedestrian or walking without dangerous SAC-scales | foot access | !foot image hike | Pedestrian or walking with priority for more beautiful hiking tours and potentially a bit longer than foot. Walking duration is influenced by elevation differences. | foot access | !hike image bike | Trekking bike avoiding hills | bike access | !bike image mtb | Mountainbike | bike access | !Mountainbike image racingbike| Bike preferring roads | bike access | !racingbike image Please note: * all motor vehicles (car, small_truck, truck and scooter) support turn restrictions via turn_costs=true * the free package supports only the vehicle profiles car, bike or foot * up to 2 different vehicle profiles can be used in a single optimization request. The number of vehicles is unaffected and depends on your subscription. * we offer custom vehicle profiles with different properties, different speed profiles or different access options. To find out more about custom profiles, please contact us. * a sophisticated motorcycle profile is available up on request. It is powered by the Kurviger Routing API and favors curves and slopes while avoiding cities and highways. TomTom If you want to include traffic, you can purchase the TomTom Add-on. This Add-on only uses TomTom's road network and historical traffic information. Live traffic is not yet considered. If you are interested to learn how we consider traffic information, we recommend that you read this article. Please note the following: * Currently we only offer this for our Route Optimization API. * In addition to our terms, you need to accept TomTom's End User License Aggreement. We do not* use TomTom's web services. We only use their data with our software. Contact us for more details. Geographical Coverage We offer - Europe including Russia - North, Central and South America - Saudi Arabia - United Arab Emirates - South Africa - Australia Supported Vehicle Profiles Name | Description | Restrictions | Icon -----------|:----------------------|:--------------------------|:--------------------------------------------------------- car | Car mode | car access | !car image small_truck| Small truck like a Mercedes Sprinter, Ford Transit or Iveco Daily | height=2.7m, width=2+0.4m, length=5.5m, weight=2080+1400 kg | !small truck image",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "API Support",
      "documentation_url": "https://www.graphhopper.com/",
      "version": "1.0.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "GraphHopper Directions API",
      "paths_count": 14,
      "schemas_count": 56
    }
  },
  {
    "name": "greenwire_public_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/greenpeace.org/1.0.0/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Greenpeace Greenwire allows you connect with other volunteers, activists and groups working on environmental campaigns all across the world!",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Greenpeace International contact",
      "documentation_url": "http://www.greenpeace.org/international/en/about/contactus/",
      "version": "1.0.0",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Greenwire Public API",
      "paths_count": 6,
      "schemas_count": 21
    }
  },
  {
    "name": "gsmtasks_project_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/gsmtasks.com/2.4.13/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The GSMtasks API is a RESTful web service for developers to programmatically interact with GSMtasks data, real-time delivery and task management and route optimization functionality.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "gsmtasks.com",
      "documentation_url": "https://gsmtasks.com",
      "version": "2.4.13",
      "openapi_version": "3.0.3",
      "quality_score": 100,
      "is_popular": false,
      "title": "GSMTasks Project API",
      "paths_count": 156,
      "schemas_count": 224
    }
  },
  {
    "name": "handwrytten_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/handwrytten.com/1.0.0/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is the Handwrytten API for sending cards written in the handwriting of your choice. Using this api, you can send cards to users. You can also customize cards with logos, which can be saved and then used like any other card in the system. For a \"sandbox\" account, please contact contact@handwrytten.com To move from credit card per-transaction to monthly invoicing, also contact us. https://www.handwrytten.com",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "handwrytten.com",
      "documentation_url": "https://handwrytten.com",
      "version": "1.0.0",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Handwrytten API",
      "paths_count": 26,
      "schemas_count": 16
    }
  },
  {
    "name": "hhs_media_services_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/hhs.gov/2/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Common Features / Behaviors * \"sort\" param: supports multi column sorting through the use of commas as delimiters, and a hyphen to denote descending order. Examples: namesort results by name ascending -namesort results by name descending -name,idsort results by name descending and then by id ascending id,-dateContentAuthoredsort results by id ascending and then date descending Date formats: Date input format is expected to be based on RFC 3339. Example: 2013-11-18T18:43:01Z",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "hhs.gov",
      "documentation_url": "https://hhs.gov",
      "version": "2",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "HHS Media Services API",
      "paths_count": 31,
      "schemas_count": 47
    }
  },
  {
    "name": "httpbin_org",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/httpbin.org/0.9.2/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "A simple HTTP Request & Response Service. Run locally: $ docker run -p 80:80 kennethreitz/httpbin",
      "category": "General",
      "last_updated": "2025-08-03",
      "maintainer": "httpbin.org",
      "documentation_url": "https://kennethreitz.org",
      "version": "0.9.2",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "httpbin.org",
      "paths_count": 52,
      "schemas_count": 0
    }
  },
  {
    "name": "id4i_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/id4i.de/1.0.2/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "ID4i HTTP API",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "BlueRain Software GmbH & Co. KG",
      "documentation_url": "http://bluerain.de",
      "version": "1.0.2",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "ID4i API",
      "paths_count": 70,
      "schemas_count": 78
    }
  },
  {
    "name": "api_reference_ideal_postcodes",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/ideal-postcodes.co.uk/3.7.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Getting Started Overview Access All API methods are either a GET, POST or OPTIONS request. The API communicates over both HTTPS and plain HTTP using IPv4 and IPv6. We recommend using HTTPS only although HTTP is available. We use appropriate HTTP status codes where possible to indicate the request status. Rate Limiting Each IP address is rate limited at 30 requests per second. Tripping the rate limit will result in a 503 response. The autocomplete API also has an additional rate limit. If you expect to breach the limit please contact us and we can move you to an endpoint with a higher limit. JSONP JSONP requests are supported. Include a callback= in your request as a query parameter. Your results return wrapped in a function designated by your request. Authentication Most requests require an API key for authentication. Authenticate by passing an api_key as part of the query string. For example: Alternatively, authentication can be transmitted via the Authorization header using the following scheme: Versioning This API is versioned with a simple prefix in the URL. The current version is /v1/. We will maintain backwards-compatibility by releasing breaking changes under a new version. Please note that the following changes are backwards-compatible: - Adding new properties to existing API responses - Adding new API endpoints - Adding new optional request parameters to existing API endpoints - Changing the order of properties in existing API responses - Changing the autocomplete address suggestion format Error Handling A successful lookup is accompanied with a HTTP status code of 200 and a response code of 2000 (found in the body). An error has occurred if the HTTP status code is not 200. Errors can range from a benign 404 (resource not found) to more urgent errors (your API Key ran out of credit, failed authentication, etc). Testing Each new account comes with a free test balance. Contact us if you need more for testing and integration. Community Key Our documentation and demos make heavy use of our community key iddqd. This allows for convenient access for trialing the API. Many restrictions on this key are relaxed to allow developers make test requests. This key has a limit of 15 lookups per IP address per day as well as a daily usage cap. If you hit any limit restrictions, you can continue testing the API by creating a key of your own and using our free test methods. Please be kind with the community key. We're trusting everyone to use it responsibly so that other developers may trial the API. Thank you! Metadata Requests that affect your balance may be annotated with arbitrary metadata. This data is stored along with your lookup history and can be queried at a later date via the API or the dashboard. We call the ability to label your requests tagging. Response Codes The API returns two indicators to help you to determine the status of each HTTP request. The first is the HTTP Status, which is found in the status-line of all HTTP requests. The API will return status codes that adhere to HTTP /1.1 Specifications wherever possible. 2XX status codes indicates success while 4XX and 5XX indicate client and server errors respectively. The second is the API response code, which can be found in the code property of the response body. This code will provide a more specific reason if a failure has occurred and can point you in the right direction when debugging. Please use the glossary of code numbers and HTTP status codes below when debugging your requests. 200 Request Success | HTTP Code | API Code | Description | | --------- | -------- | -------------------------------------------- | | 200 | 2000 | Success. Request was completed successfully. | 400 Bad Request The request could not be understood due to some input error. | HTTP Code | API Code | Description | | --------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------- | | 400 | 4000 | Invalid syntax submitted. Some part of your request was malformed or did not match our specifications. | | 400 | 4001 | Validation failed on your submitted data. Some of the data you provided did not meet our validation requirements, e.g. string length. | | 400 | 4005 | Invalid start date. Please ensure start dates are provided as a UTC Timestamp in milliseconds. | | 400 | 4006 | Invalid end date. Please ensure end dates are provided as a UTC Timestamp in milliseconds. | | 400 | 4007 | Invalid date range. Check if your start and end dates are in the right order. | | 400 | 4008 | Invalid date range. Check that your date range is 90 days or less. | | 400 | 4009 | Too many tags. Please specify no more than 3 tags to query. | 401 Unauthorised Authorization credentials are not valid. | HTTP Code | API Code | Description | | --------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | 401 | 4010 | Invalid Key. The api_key you provided is not valid. | | 401 | 4011 | Requesting URL not on whitelist. The cross domain request is not coming from a whitelisted URL. You can update or disable your allowed URLs via your Key settings. | | 401 | 4012 | Failed user authentication. Invalid user_token presented. | | 401 | 4013 | Licensee Key is required. Sublicensed keys require you need to present licensee credentials via the licensee parameter. | 402 Request Failed Your request is well-formed but are not able to complete your request for another reason. | HTTP Code | API Code | Description | | --------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | 402 | 4020 | Key balance depleted. You're out of lookups on your API Key. | | 402 | 4021 | Limit reached. One of your lookup limits has been breached for today. This could either be your total daily limit on your key or the individual IP limit. You can either wait for for the limit to reset (after a day) or manually disable or increase your limit. | 404 Resource Not Found The resource you requested does not exist. | HTTP Code | API Code | Description | | --------- | -------- | --------------------------------------------------------------------------------------------- | | 404 | 4040 | Postcode not found. The postcode you have submitted does not exist. | | 404 | 4041 | User not found. Your user could not be identified given the credentials you presented. | | 404 | 4042 | Key not found. Your key could not be identified given the credentials you presented. | | 404 | 4044 | No UDPRN found. No address is associated with the UDPRN queried | | 404 | 4045 | No licensee found. Your licensee could not be identified given the credentials you presented. | | 404 | 4046 | No UMPRN found. No Multiple Residence premise is associated with the UMPRN queried. | 500 Server Error A error occurred on our server. | HTTP Code | API Code | Description | | --------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | 500 | 5000 | An error occurred on our end. These errors are logged and queued so we can understand what went wrong. However, if you need speedy resolution please email support | | 500 | 5001 | Akin to 5000. | | 500 | 5002 | The server took too long to process on our end, so we aborted the request. You may retry the request. |",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Support",
      "documentation_url": "https://docs.ideal-postcodes.co.uk",
      "version": "3.7.0",
      "openapi_version": "3.0.3",
      "quality_score": 100,
      "is_popular": false,
      "title": "API Reference - Ideal Postcodes",
      "paths_count": 20,
      "schemas_count": 194
    }
  },
  {
    "name": "instagram_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/instagram.com/1.0.0/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Description of Instagram RESTful API. Current limitations: * Instagram service does not support cross origin headers for security reasons, therefore it is not possible to use Swagger UI and make API calls directly from browser. * Modification API requests (POST, DELETE) require additional security scopes that are available for Apps created on or after Nov 17, 2015 and started in Sandbox Mode. * Consider the Instagram limitations for API calls that depends on App Mode. Warning: For Apps created on or after Nov 17, 2015 API responses containing media objects no longer return the data field in comments and likes nodes. Last update: 2015-11-28",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Instagram",
      "documentation_url": "https://instagram.com/developer",
      "version": "1.0.0",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": true,
      "title": "Instagram API",
      "paths_count": 23,
      "schemas_count": 36
    }
  },
  {
    "name": "brain_web_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/intellifi.nl/2.23.4+0.gb463b49.dirty/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This document describes the Intellifi Brain Web API specification using the OpenAPI specification. The Brain Web API is a RESTful API that allows you to interact with the Intellifi devices and services in a powerful and simple way. Our end-to-end solution allows you to localize your items/assets based on technologies such as RFID and Bluetooth. Try it out! The API can be tried out and tested using the 'api-doc/tryitout' endpoint on this site. This UI allows anyone to visualize and interact with the API’s resources without having any of the implementation logic in place. It’s automatically generated from this Specification, with the visual documentation making it easy for back end implementation and client side consumption. Authentication Applications are required to provide some form of authentication to the API for every secured endpoint. The Brain offers two forms of authentication. - API key (Via an HTTP request header or URL parameter) - Session cookie --> See also - About Intellifi and what we do: intellifi.nl - Technical and background information: intellifi.zendesk.com",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Support",
      "documentation_url": "https://intellifi.zendesk.com",
      "version": "2.23.4+0.gb463b49.dirty",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "Brain Web API",
      "paths_count": 40,
      "schemas_count": 76
    }
  },
  {
    "name": "iqualify_management_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/iqualify.com/v1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The iQualify API offers management responses for building learning experiences using your iQualify instance data. Once you’ve registered with iQualify, you can request an API access token by navigating to the API access section of the \"Account Settings\" area. Find out how to Request your API access token on our Knowledge base. All endpoints are only accessible via https and are located at api.iqualify.com. For instance: you can find your current offerings by accessing the following URL: https://api.iqualify.com/v1/offerings/current",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "iqualify.com",
      "documentation_url": "https://iqualify.com",
      "version": "v1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "iQualify Management API",
      "paths_count": 74,
      "schemas_count": 70
    }
  },
  {
    "name": "api_isendpro",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/isendpro.com/1.1.1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "[1] Liste des fonctionnalités : - envoi de SMS à un ou plusieurs destinataires, - lookup HLR, - récupération des récapitulatifs de campagne, - gestion des répertoires, - ajout en liste noire. - comptage du nombre de caractères des SMS [2] Pour utiliser cette API vous devez: - Créer un compte iSendPro sur https://isendpro.com/ - Créditer votre compte - Remarque: obtention d'un crédit de test possible sous conditions - Noter votre clé de compte (keyid) - Elle vous sera indispensable à l'utilisation de l'API - Vous pouvez la trouver dans le rubrique mon \"compte\", sous-rubrique \"mon API\" - Configurer le contrôle IP - Le contrôle IP est configurable dans le rubrique mon \"compte\", sous-rubrique \"mon API\" - Il s'agit d'un système de liste blanche, vous devez entrer les IP utilisées pour appeler l'API - Vous pouvez également désactiver totalement le contrôle IP",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "iSendPro Support Team",
      "documentation_url": "https://www.isendpro.com/",
      "version": "1.1.1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "API iSendPro",
      "paths_count": 12,
      "schemas_count": 35
    }
  },
  {
    "name": "ix_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/ix-api.net/2.1.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This API allows to config/change/delete Internet Exchange services. Filters When querying collections, the provided query parameters are validated. Unknown query parameters are ignored. Providing invalid filter values should yield a validation error.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "ix-api.net",
      "documentation_url": "https://ix-api.net",
      "version": "2.1.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "IX-API",
      "paths_count": 45,
      "schemas_count": 220
    }
  },
  {
    "name": "firebase_cloud_messaging_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/javatpoint.com/v1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "FCM send API that provides a cross-platform messaging solution to reliably deliver messages at no cost.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Google",
      "documentation_url": "https://firebase.google.com/docs/cloud-messaging",
      "version": "v1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Firebase Cloud Messaging API",
      "paths_count": 1,
      "schemas_count": 13
    }
  },
  {
    "name": "developer_documentation",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/journy.io/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Welcome Implementing a new tool can be daunting, but it doesn't have to. You can implement journy.io in a few different ways to ensure it fits with the rest of your tech stack seamlessly. We welcome your feedback, ideas and suggestions. We really want to make your life easier, so if we’re falling short or should be doing something different, we want to hear about it. Send us an email at hi@journy.io or reach out via the chat on our website or on our platform. There are multiple ways you can send us data about users and accounts. We have both frontend and backend APIs, which can be used together at the same time. If you already use Segment, you can get up and running with journy.io in seconds. Concepts Users The most basic entity is a user, a specific individual that completed an interaction with your product. We support multiple types of users, often differentiated by it's external ID prefix. E.g. In the case you are building an ordering app, there could easily be an administrator (who updates products and checks for orders) and the end-customers who place orders. One could have a typical ADM-XXXXXXXX ID, while the other would be referenced by USR-XXXXXXXXX. Accounts In B2B SaaS, users can be part of multiple accounts. E.g. Imagine you're building a content scheduling app where an agency can manage the social media posts of their clients. Each client of the agency has its own account in the product. If your app doesn't have the concept of a team or group of users, you can ignore accounts. Events An event is a data point that represents an interaction between a user and/or an account; and your product. Events can represents any range of interactions. E.g. Every time a customer creates an invoice in an invoicing app. Actions like creating an invoice can be tracked as an event in journy.io. It's critical to track events properly. You'll need to provide either an account ID, or a user ID, or both; when tracking an event. E.g. If a user updates his personal settings, you can omit the account ID as the event would not be related to any account. In a same logic, an account could get a 'suspend account' event (with account ID) from an internal process, whereas no user would be associated. In most cases, events will be associated to both 1 user and 1 account. You can optionally pass extra details as metadata (e.g. amount of the invoice). This gets particarly powerfull when creating computed properties on those event metadata. E.g. Our above ordering app could send journy.io 'Place Order' events with metadata 'price', on which journy.io very easily would compute a total order value (for each account) for the last 30 days. 💡 Metadata does not update the properties of a user or account. Frontend vs backend The best implementations we see employ a hybrid approach to maximize data quality while maintaining the flexibility to easily collect the data they need. We recommend using our JavaScript snippet to track screen views and our backend API to sync users, sync accounts and track events. When evaluating how to track a particular event, we suggest starting with server-side and only use frontend if it's not possible to collect purely server-side. This can be the case if you need to track interactions with your product that don't result in any natural server requests (such as a button click that opens a modal). Frontend Setup 💡 You can find the JavaScript snippet in the website settings in the connections view. Copy the JavaScript snippet and place it in the head or body of your application. The snippet automatically calls journy(\"init\", { ... }) and journy(\"pageview\"). Identify user 💡 A user ID should be a robust, static, unique identifier that you recognize a user by in your own systems. Because these IDs are consistent across a customer’s lifetime, you should include a user ID in identify calls as often as you can. Ideally, the user ID should be a database ID. 💡 journy.io does not recommend using simple email addresses or usernames as user ID, as these can change over time. journy.io recommends that you use static IDs instead, so the IDs never change. When you use a static ID, you can still recognize the user in your analytics tools, even if the user changes their email address. 💡 The properties full_name, first_name, last_name, phone and registered_at will be used for creating contacts in destinations like Intercom, HubSpot, Salesforce, ... journy(\"identify\") allows you to identify the user that is currently using your product. Identify account 💡 An account ID should be a robust, static, unique identifier that you recognize an account by in your own systems. Ideally, the account ID should be a database ID. 💡 The properties name, mrr, plan and registered_at will be used to create companies in destinations like Intercom, HubSpot, Salesforce, ... journy(\"account\") allows you to identify the business account (i.e. organization) using your product. Send page view 💡 In applications, we advise you to use screen views instead of page views. The JavaScript snippet in the site settings includes a pageview by default. If you have a B2B application, we recommend to set account ID for every page view that happens within the context of an account. 💡 An account ID should be a robust, static, unique identifier that you recognize an account by in your own systems. Ideally, the account ID should be a database ID. Send screen view In applications, we strongly advise you to use screen views instead of page views. Page URLs in applications often include the account ID (e.g. https://app.acme.com/accountId/settings). This makes it difficult to create signals, segments, ... based on those URLs. That's what screen views solve. It allows you to set a name for the screen being viewed (e.g. Account settings). If you have a B2B application, we recommend to set account ID for every screen view that happens within the context of an account. Example: \"Personal settings\" would be without account ID, \"Team settings\" would be with account ID. 💡 An account ID should be a robust, static, unique identifier that you recognize an account by in your own systems. Ideally, the account ID should be a database ID. Trigger an event 💡 Use past tense for event names. User events: Account events: 💡 An account ID should be a robust, static, unique identifier that you recognize an account by in your own systems. Ideally, the account ID should be a database ID. Identity verification Identity verification ensures that one person can't impersonate another. Identity verification requires you to add an hash (HMAC) (that you generate on your server using SHA256) to your installation snippet alongside your user ID and account ID. journy.io won't accept requests for a logged-in user without a valid hash. The hash is calculated using a secret key, which you should never share. Without this secret key, no third party can send journy.io a valid hash for one of your users, so they can't impersonate your users. This is optional but highly recommended. You can enable identify verification in the website settings in the connections view. PHP Vue Router You can use router.afterEach to listen for route changes: Note: We don't accept a page URL argument for journy(\"pageview\"). The current page URL will always be resolved using window.location.href. TypeScript We published an npm package with type definitions to enable type-safe usage of our JavaScript snippet. The code and documentation is available on GitHub. Localhost By default a site doesn't allow page views from other domains than the registered domain. This makes it difficult to test your tracking implementation locally. You can enable \"Allow any domain\" in the site settings to disable the domain check. This will allow you to test the JavaScript snippet with localhost as hostname. Backend The journy.io API is organized around REST. Our API has predictable resource-oriented URLs, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs. The API is hosted on api.journy.io. Official SDKs Our SDKs are designed to help you interact with our APIs with less friction. They are written in several different languages and help bridge the gap between your application and journy.io APIs. They take away the need to know the exact URL and HTTP method to use for each API call among other things leaving you more time to focus on making your application. | Language | Package | Source code | |------------|--------------------------------------------------------------------------------|----------------------------------------------------------------------------| | 💚 Node.js | npm install @journyio/sdk | github.com/journy-io/js-sdk | | 🐘 PHP | composer require journy-io/sdk | github.com/journy-io/php-sdk | | 🐍 Python | pip install journyio-sdk | github.com/journy-io/python-sdk | | 💎 Ruby | Coming soon | Coming soon | Your favourite programming language not included? Let us know! In the meanwhile, you can use OpenAPI Generator to generate a client for your programming language. Authentication The journy.io API uses API keys to authenticate requests. You can view and manage your API keys in the connections screen. Your API keys carry many privileges, so be sure to keep them secure! Do not share your secret API keys in publicly accessible areas such as GitHub, client-side code, and so forth. All API requests must be made over HTTPS. Calls made over plain HTTP will fail. API requests without authentication will also fail. For every request send to the API we expect a header X-Api-Key to be set with the API Key. Permissions When creating an API Key in the application you will have the choice to give permissions to an API Key (which you can change later on). These permissions restrict the API Key from different actions. When an API Key tries to perform a certain action it doesn't have the permissions for, you will receive a 401: Unauthorized response. Rate limiting To prevent abuse of the API there is a maximum throughput of 1800 requests per minute. If you need a higher throughput, please contact us. To keep our platform healthy and stable, we'll block API keys that consistently hit our rate limits. Therefore, please consider taking this throughput into account. In every response the headers X-RateLimit-Limit and X-RateLimit-Remaining will be set. The X-RateLimit-Limit-header will always contain the current limit of requests per minute. The X-RateLimit-Remaining-header will always contain the amount of requests you have left in the current sliding window. 💡 The client-side tracking uses different rate limits. Errors journy.io uses conventional HTTP response codes to indicate the success or failure of an API request. In general: Codes in the 2xx range indicate success. Codes in the 4xx range indicate an error that failed given the information provided (e.g. a required parameter was omitted). Codes in the 5xx range indicate an error with journy.io's servers (these are rare). When performing a POST- or PUT-request with a requestBody, or when including parameters, these parameters and fields will automatically be checked and validated against the API Spec. When any error occurs, you will get a response with an errors-field, structured as follows: Best practices Track accounts & users immediately on creation When you create an account in your database, immediately sending data about that account to journy.io helps your team stay in sync. The same goes for users. Call Upsert account as soon as possible, right after the account is first created in your database. Update account data daily Not every account is active every day. But, you may have properties on the account that change through background processing. That's why we recommend updating every one of your accounts' data in a recurring daily process. This way, you know that your accounts are updated every day in journy.io. Changelog December 2021 POST /events will be moved to POST /track. POST /events is deprecated and will be removed in the future.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Support",
      "documentation_url": "https://help.journy.io",
      "version": "1.0.0",
      "openapi_version": "3.0.3",
      "quality_score": 100,
      "is_popular": false,
      "title": "Developer documentation",
      "paths_count": 15,
      "schemas_count": 0
    }
  },
  {
    "name": "jumpseller_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/jumpseller.com/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Endpoint Structure All URLs are in the format: The path is prefixed by the API version and the URL takes as parameters the login (your store specific API login) and your authentication token. * Version The current version of the API is v1. If we change the API in backward-incompatible ways, we'll increase the version number and maintain stable support for the old urls. * Authentication The API uses a token-based authentication with a combination of a login key and an auth token. Both parameters can be found on the left sidebar of the Account section, accessed from the main menu of your Admin Panel. The auth token of the user can be reset on the same page. !Store Login The auth token is a 32 characters string. If you are developing a Jumpseller App, the authentication should be done using OAuth-2. Please read the article Build an App for more information. * Curl Examples To request all the products at your store, you would append the products index path to the base url to create an URL with the format: In curl, you can invoque that URL with: To create a product, you will include the JSON data and specify the MIME Type: and to update the product identified with 123: or delete it: * PHP Examples Create a new Product (POST method) * Plain JSON only. No XML. * We only support JSON for data serialization. * Our node format has no root element. * We use snake_case to describe attribute keys (like \"created_at\"). * All empty value are replaced with null strings. * All API URLs end in .json to indicate that they accept and return JSON. * POST and PUT methods require you to explicitly state the MIME type of your request's body content as \"application/json\". * Rate Limit You can perform a maximum of: + 240 (two hundred forty) requests per minute and + 8 (eight) requests per second If you exceed this limit, you'll get a 403 Forbidden (Rate Limit Exceeded) response for subsequent requests. The rate limits apply by IP address and by store. This means that multiple requests on different stores are not counted towards the same rate limit. This limits are necessary to ensure resources are correctly used. Your application should be aware of this limits and retry any unsuccessful request, check the following Ruby stub: Finally, you can review the Response Headers of each request: to better model your application requests intervals. In the event of getting your IP banned, the Response Header Jumpseller-BannedByRateLimit-Reset informs you the time when will your ban be reseted. * Pagination By default we will return 50 objects (products, orders, etc) per page. There is a maximum of 100, using a query string &limit=100. If the result set gets paginated it is your responsibility to check the next page for more objects -- you do this by using query strings &page=2, &page=3 and so on. * More * Jumpseller API wrapper provides a public Ruby abstraction over our API; * Apps Page showcases external integrations with Jumpseller done by technical experts; * Imgbb API provides an easy way to upload and temporaly host for images and files. *",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "jumpseller.com",
      "documentation_url": "https://jumpseller.com",
      "version": "1.0.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Jumpseller API",
      "paths_count": 82,
      "schemas_count": 148
    }
  },
  {
    "name": "just_eat_uk",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/just-eat.co.uk/1.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Just Eat API Just Eat offers services for our various business partners and our consumer applications. How you interact with the API depends on the services you wish to interact with. Security HTTPS All api calls and callbacks require HTTPS. Your service will need a valid SSL certificate and be accessible via the standard SSL port (port 443). Making an API request Some API calls require an API key, to authenticate the partner calling the API. Other calls require a user token in the form of a JWT. Date Formats Date and time formats All dates and times should use the ISO 8601 standard for representation of dates and times. For instance: * DueDateWithUtcOffset: \"2015-05-26T14:52:35.5444292+01:00\" - Local time: 14:52 - UTC time: 13:52 - UTC offset: +1hr (due to daylight time saving) * DueDateWithUtcOffset: \"2015-02-03T11:10:00.0000000+00:00\" - Local time: 11:10 - UTC time: 11:10 - UTC offset: 0 (no daylight time saving, local time is equivalent to UTC) Note that the offset may be for a timezone different to your own, so you should alway convert to your own local time for display purposes (e.g. on receipts and terminals). Callback timestamps Timestamps sent to Just Eat should be recorded as the current local time (including any changes needed to account for daylight saving) with an accompanying offset that shows the difference between the recorded local time and the current UTC time. If it is not possible to record timestamps in local time, timestamps may be recorded in UTC time with a 00:00 offset. Async Webhooks Some of the webhooks on the platform are configured as being 'async' webhooks. These are for long-running operations, and work as follows: 1. Your webhook is invoked with a ?callback={returnUrl} query string parameter. The returnUrl is a unique URL that you will need to send the async response to. 2. Return an immediate 202 Accepted response from the webhook endpoint, to indicate that you have received the request. 3. Perform the long-running operation. This can be deemed either a _success_; or a _failure_. 4. If the result is a _success_, return the following: 5. Otherwise, if the result is a _failure_, return the following:",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "just-eat.co.uk",
      "documentation_url": "https://just-eat.co.uk",
      "version": "1.0.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Just Eat UK",
      "paths_count": 85,
      "schemas_count": 671
    }
  },
  {
    "name": "keycloak_admin_rest_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/keycloak.local/1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is a REST API reference for the Keycloak Admin",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "keycloak.local",
      "documentation_url": "https://github.com/keycloak/keycloak/tree/6.0.1/core/src/main/java/org/keycloak/representations",
      "version": "1",
      "openapi_version": "3.0.2",
      "quality_score": 100,
      "is_popular": false,
      "title": "Keycloak Admin REST API",
      "paths_count": 192,
      "schemas_count": 65
    }
  },
  {
    "name": "kumpeapps_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/kumpeapps.com/5.0.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "KKid API. Due to security concerns all calls to this API requires authentication. If you have access then you may use your KumpeApps username/password to authenticate. To gain access please use the contact developer link below.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "kumpeapps.com",
      "documentation_url": "https://kumpeapps.com",
      "version": "5.0.0",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "KumpeApps API",
      "paths_count": 13,
      "schemas_count": 21
    }
  },
  {
    "name": "launchdarkly_rest_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/launchdarkly.com/5.3.0/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Build custom integrations with the LaunchDarkly REST API",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "LaunchDarkly Support",
      "documentation_url": "https://support.launchdarkly.com",
      "version": "5.3.0",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "LaunchDarkly REST API",
      "paths_count": 64,
      "schemas_count": 107
    }
  },
  {
    "name": "lgtm_api_specification",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/lgtm.com/v1.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The REST API for LGTM provides data so that you can customize how you integrate LGTM analysis into your workflow. It includes the following resources: * / (API root)&mdash;get version information or download the specification in OpenAPI format. * /projects (Projects)&mdash;list projects, get a summary of the current status for a project, or add new projects. * /analyses (Analyses)&mdash;get a summary of results, download all the alerts, or trigger analysis for a specific commit. * /codereviews (Code reviews)&mdash;trigger code review for a patch, and view the results. * /operations (Operations)&mdash;get information about long-running tasks, for example, analyses or code reviews that you've requested. * /snapshots (Snapshots)&mdash;download and upload databases representing a snapshot of a codebase. * /queryjobs (Query jobs)&mdash;submit queries to evaluate against existing projects, and download their results. * /system (System)&mdash;get information on the health or usage of the system. For an overview and getting started topics, see API for LGTM.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "lgtm.com",
      "documentation_url": "https://lgtm.com",
      "version": "v1.0",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "LGTM API specification",
      "paths_count": 23,
      "schemas_count": 25
    }
  },
  {
    "name": "linode_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/linode.com/4.151.1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Introduction The Linode API provides the ability to programmatically manage the full range of Linode products and services. This reference is designed to assist application developers and system administrators. Each endpoint includes descriptions, request syntax, and examples using standard HTTP requests. Response data is returned in JSON format. This document was generated from our OpenAPI Specification. See the OpenAPI website for more information. Download the Linode OpenAPI Specification. Changelog View our Changelog to see release notes on all changes made to our API. Access and Authentication Some endpoints are publicly accessible without requiring authentication. All endpoints affecting your Account, however, require either a Personal Access Token or OAuth authentication (when using third-party applications). Personal Access Token The easiest way to access the API is with a Personal Access Token (PAT) generated from the Linode Cloud Manager or the Create Personal Access Token endpoint. All scopes for the OAuth security model (defined below) apply to this security model as well. Authentication | Security Scheme Type: | HTTP | |-----------------------|------| | HTTP Authorization Scheme | bearer | OAuth If you only need to access the Linode API for personal use, we recommend that you create a personal access token. If you're designing an application that can authenticate with an arbitrary Linode user, then you should use the OAuth 2.0 workflows presented in this section. For a more detailed example of an OAuth 2.0 implementation, see our guide on How to Create an OAuth App with the Linode Python API Library. Before you implement OAuth in your application, you first need to create an OAuth client. You can do this with the Linode API or via the Cloud Manager: - When creating the client, you'll supply a label and a redirect_uri (referred to as the Callback URL in the Cloud Manager). - The response from this endpoint will give you a client_id and a secret. - Clients can be public or private, and are private by default. You can choose to make the client public when it is created. - A private client is used with applications which can securely store the client secret (that is, the secret returned to you when you first created the client). For example, an application running on a secured server that only the developer has access to would use a private OAuth client. This is also called a confidential client in some OAuth documentation. - A public client is used with applications where the client secret is not guaranteed to be secure. For example, a native app running on a user's computer may not be able to keep the client secret safe, as a user could potentially inspect the source of the application. So, native apps or apps that run in a user's browser should use a public client. - Public and private clients follow different workflows, as described below. OAuth Workflow The OAuth workflow is a series of exchanges between your third-party app and Linode. The workflow is used to authenticate a user before an application can start making API calls on the user's behalf. Notes: - With respect to the diagram in section 1.2 of RFC 6749, login.linode.com (referred to in this section as the login server) is the Resource Owner and the Authorization Server; api.linode.com (referred to here as the api server) is the Resource Server. - The OAuth spec refers to the private and public workflows listed below as the authorization code flow and implicit flow. | PRIVATE WORKFLOW | PUBLIC WORKFLOW | |------------------|------------------| | 1. The user visits the application's website and is directed to login with Linode. | 1. The user visits the application's website and is directed to login with Linode. | | 2. Your application then redirects the user to Linode's login server with the client application's client_id and requested OAuth scope, which should appear in the URL of the login page. | 2. Your application then redirects the user to Linode's login server with the client application's client_id and requested OAuth scope, which should appear in the URL of the login page. | | 3. The user logs into the login server with their username and password. | 3. The user logs into the login server with their username and password. | | 4. The login server redirects the user to the specificed redirect URL with a temporary authorization code (exchange code) in the URL. | 4. The login server redirects the user back to your application with an OAuth access_token embedded in the redirect URL's hash. This is temporary and expires in two hours. No refresh_token is issued. Therefore, once the access_token expires, a new one will need to be issued by having the user log in again. | | 5. The application issues a POST request (see additional details below) to the login server with the exchange code, client_id, and the client application's client_secret. | | | 6. The login server responds to the client application with a new OAuth access_token and refresh_token. The access_token is set to expire in two hours. | | | 7. The refresh_token can be used by contacting the login server with the client_id, client_secret, grant_type, and refresh_token to get a new OAuth access_token and refresh_token. The new access_token is good for another two hours, and the new refresh_token can be used to extend the session again by this same method (see additional details below). | | OAuth Private Workflow - Additional Details The following information expands on steps 5 through 7 of the private workflow: Once the user has logged into Linode and you have received an exchange code, you will need to trade that exchange code for an access_token and refresh_token. You do this by making an HTTP POST request to the following address: Make this request as application/x-www-form-urlencoded or as multipart/form-data and include the following parameters in the POST body: | PARAMETER | DESCRIPTION | |-----------|-------------| | client_id | Your app's client ID. | | client_secret | Your app's client secret. | | code | The code you just received from the redirect. | You'll get a response like this: Included in the response is an access_token. With this token, you can proceed to make authenticated HTTP requests to the API by adding this header to each request: This access_token is set to expire in two hours. To refresh access prior to expiration, make another request to the same URL with the following parameters in the POST body: | PARAMETER | DESCRIPTION | |-----------|-------------| | grant_type | The grant type you're using. Use \"refresh_token\" when refreshing access. | | client_id | Your app's client ID. | | client_secret | Your app's client secret. | | refresh_token | The refresh_token received from the previous response. | You'll get another response with an updated access_token and refresh_token, which can then be used to refresh access again. OAuth Reference | Security Scheme Type | OAuth 2.0 | |-----------------------|--------| | Authorization URL | https://login.linode.com/oauth/authorize | | Token URL | https://login.linode.com/oauth/token | | Scopes | account:read_only - Allows access to GET information about your Account.account:read_write - Allows access to all endpoints related to your Account.databases:read_only - Allows access to GET Managed Databases on your Account.databases:read_write - Allows access to all endpoints related to your Managed Databases.domains:read_only - Allows access to GET Domains on your Account.domains:read_write - Allows access to all Domain endpoints.events:read_only - Allows access to GET your Events.events:read_write - Allows access to all endpoints related to your Events.firewall:read_only - Allows access to GET information about your Firewalls.firewall:read_write - Allows access to all Firewall endpoints.images:read_only - Allows access to GET your Images.images:read_write - Allows access to all endpoints related to your Images.ips:read_only - Allows access to GET your ips.ips:read_write - Allows access to all endpoints related to your ips.linodes:read_only - Allows access to GET Linodes on your Account.linodes:read_write - Allow access to all endpoints related to your Linodes.lke:read_only - Allows access to GET LKE Clusters on your Account.lke:read_write - Allows access to all endpoints related to LKE Clusters on your Account.longview:read_only - Allows access to GET your Longview Clients.longview:read_write - Allows access to all endpoints related to your Longview Clients.nodebalancers:read_only - Allows access to GET NodeBalancers on your Account.nodebalancers:read_write - Allows access to all NodeBalancer endpoints.object_storage:read_only - Allows access to GET information related to your Object Storage.object_storage:read_write - Allows access to all Object Storage endpoints.stackscripts:read_only - Allows access to GET your StackScripts.stackscripts:read_write - Allows access to all endpoints related to your StackScripts.volumes:read_only - Allows access to GET your Volumes.volumes:read_write - Allows access to all endpoints related to your Volumes.| Requests Requests must be made over HTTPS to ensure transactions are encrypted. Data included in requests must be supplied in json format unless otherwise specified in the command description. The following request methods are supported: | METHOD | USAGE | |---------|-------| | GET | Retrieves data about collections and individual resources. | | POST | For collections, creates a new resource of that type. Also used to perform actions on action endpoints. | | PUT | Updates an existing resource. | | DELETE | Deletes a resource. This is a destructive action. | | HEAD | Returns only the response header information of a GET request | | OPTIONS | Provides permitted communication options for a command | Responses Response Status Codes Actions will return one of the following HTTP response status codes: | STATUS | DESCRIPTION | |---------|-------------| | 200 OK | The request was successful. | | 202 Accepted | The request was successful, but processing has not been completed. The response body includes a \"warnings\" array containing the details of incomplete processes. | | 204 No Content | The server successfully fulfilled the request and there is no additional content to send. | | 299 Deprecated | The request was successful, but involved a deprecated endpoint. The response body includes a \"warnings\" array containing warning messages. | | 400 Bad Request | You submitted an invalid request (missing parameters, etc.). | | 401 Unauthorized | You failed to authenticate for this resource. | | 403 Forbidden | You are authenticated, but don't have permission to do this. | | 404 Not Found | The resource you're requesting does not exist. | | 429 Too Many Requests | You've hit a rate limit. | | 500 Internal Server Error | Please open a Support Ticket. | Response Headers There are many ways to access response header information for individual command URLs, depending on how you are accessing the Linode API. For example, to view HTTP response headers for the /regions endpoint when making requests with curl, use the -I or --head option as follows: Responses may include the following headers: | HEADER | DESCRIPTION | EXAMPLE | |--------|-------------|---------| | Access-Control-Allow-Credentials | Responses to credentialed requests are exposed to frontend JavaScript code. | true | | Access-Control-Allow-Headers | All permissible request headers for this endpoint. | Authorization, Origin, X-Requested-With, Content-Type, Accept, X-Filter | | Access-Control-Allow-Methods | Permissible HTTP methods for this endpoint | HEAD, GET, OPTIONS, POST, PUT, DELETE | | Access-Control-Allow-Origin | Indicates origin access permissions. The wildcard character ` means any origin can access the resource. | | | Access-Control-Expose-Headers | Available headers to include in response to cross-origin requests. | X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Status | | Cache-Control | Controls caching in browsers and shared caches such as CDNs. | private, max-age=60, s-maxage=60 | | Content-Security-Policy | Controls which resources are allowed to load. By default, resources do not load. | default-src 'none' | | Content-Type | All responses are in json format. | application/json | | Content-Warning | A message containing instructions for successful requests that were not able to be completed. | Please contact support for assistance. | | Retry-After | The remaining time in seconds until the current rate limit window resets. | 60 | | Strict-Transport-Security | Enforces HTTPS-only access until the returned time in seconds. | max-age=31536000 | | Vary | Optional request headers that affected the response content. | Authorization, X-Filter | | X-Accepted-OAuth-Scopes | Required scopes for accessing the requested command. | linodes:read_only | | X-Customer-UUID | A unique identifier for the account owning the the personal access token that was used for the request. | ABCDEF01-3456-789A-BCDEF0123456789A | | X-OAuth-Scopes | Allowed scopes associated with the personal access token that was used for the request. A value of * indicates read/write access for all scope categories. | images:read_write linodes:read_only | | X-RateLimit-Limit | The maximum number of permitted requests during the rate limit window for this endpoint. | 800 | | X-RateLimit-Remaining | The remaining number of permitted requests in the current rate limit window. | 798 | | X-RateLimit-Reset | The time when the current rate limit window rests in UTC epoch seconds. | 1674747739 | | X-Spec-Version | The current API version that handled the request. | 4.150.0 | Errors Success is indicated via Standard HTTP status codes. 2xx codes indicate success, 4xx codes indicate a request error, and 5xx errors indicate a server error. A request error might be an invalid input, a required parameter being omitted, or a malformed request. A server error means something went wrong processing your request. If this occurs, please open a Support Ticket and let us know. Though errors are logged and we work quickly to resolve issues, opening a ticket and providing us with reproducable steps and data is always helpful. The errors field is an array of the things that went wrong with your request. We will try to include as many of the problems in the response as possible, but it's conceivable that fixing these errors and resubmitting may result in new errors coming back once we are able to get further along in the process of handling your request. Within each error object, the field parameter will be included if the error pertains to a specific field in the JSON you've submitted. This will be omitted if there is no relevant field. The reason is a human-readable explanation of the error, and will always be included. Pagination Resource lists are always paginated. The response will look similar to this: * Pages start at 1. You may retrieve a specific page of results by adding ?page=x to your URL (for example, ?page=4). If the value of page exceeds 2^64/page_size, the last possible page will be returned. * Page sizes default to 100, and can be set to return between 25 and 500. Page size can be set using ?page_size=x. Filtering and Sorting Collections are searchable by fields they include, marked in the spec as x-linode-filterable: true. Filters are passed in the X-Filter header and are formatted as JSON objects. Here is a request call for Linode Types in our \"standard\" class: The filter object's keys are the keys of the object you're filtering, and the values are accepted values. You can add multiple filters by including more than one key. For example, filtering for \"standard\" Linode Types that offer one vcpu: In the above example, both filters are combined with an \"and\" operation. However, if you wanted either Types with one vcpu or Types in our \"standard\" class, you can add an operator: Each filter in the +or array is its own filter object, and all conditions in it are combined with an \"and\" operation as they were in the previous example. Other operators are also available. Operators are keys of a Filter JSON object. Their value must be of the appropriate type, and they are evaluated as described below: | OPERATOR | TYPE | DESCRIPTION | |----------|--------|-----------------------------------| | +and | array | All conditions must be true. | | +or | array | One condition must be true. | | +gt | number | Value must be greater than number. | | +gte | number | Value must be greater than or equal to number. | | +lt | number | Value must be less than number. | | +lte | number | Value must be less than or equal to number. | | +contains | string | Given string must be in the value. | | +neq | string | Does not equal the value. | | +order_by | string | Attribute to order the results by - must be filterable. | | +order | string | Either \"asc\" or \"desc\". Defaults to \"asc\". Requires +order_by. | For example, filtering for Linode Types that offer memory equal to or higher than 61440: You can combine and nest operators to construct arbitrarily-complex queries. For example, give me all Linode Types which are either standard or highmem class, or have between 12 and 20 vcpus: Time Values All times returned by the API are in UTC, regardless of the timezone configured within your user's profile (see timezone property within Profile View). Rate Limiting Rate limits on API requests help maintain the health and stability of the Linode API. Accordingly, every endpoint of the Linode API applies a rate limit on a per user basis as determined by OAuth token for authenticated requests or IP address for public endpoints. Each rate limit consists of a total number of requests and a time window. For example, if an endpoint has a rate limit of 800 requests per minute, then up to 800 requests over a one minute window are permitted. Subsequent requests to an endpoint after hitting a rate limit return a 429 error. You can successfully remake requests to that endpoint after the rate limit window resets. Linode APIv4 Rate Limits With the Linode API, you can generally make up to 1,600 general API requests every two minutes. Additionally, all endpoints have a rate limit of 800 requests per minute unless otherwise specified below. Note: There may be rate limiting applied at other levels outside of the API, for example, at the load balancer. Creating Linodes has a dedicated rate limit of 10 requests per 30 seconds. That endpoint is: * Linode Create /stats` endpoints have their own dedicated rate limits of 100 requests per minute. These endpoints are: * View Linode Statistics * View Linode Statistics (year/month) * View NodeBalancer Statistics * List Managed Stats Object Storage endpoints have a dedicated rate limit of 750 requests per second. The Object Storage endpoints are: * Object Storage Endpoints Opening Support Tickets has a dedicated rate limit of 2 requests per minute. That endpoint is: * Open Support Ticket Accepting Service Transfers has a dedicated rate limit of 2 requests per minute. That endpoint is: * Service Transfer Accept Rate Limit HTTP Response Headers The Linode API includes the following HTTP response headers which are designed to help you avoid hitting rate limits which might disrupt your applications: * X-RateLimit-Limit: The maximum number of permitted requests during the rate limit window for this endpoint. * X-RateLimit-Remaining: The remaining number of permitted requests in the current rate limit window. * X-RateLimit-Reset: The time when the current rate limit window rests in UTC epoch seconds. * Retry-After: The remaining time in seconds until the current rate limit window resets. CLI (Command Line Interface) The Linode CLI allows you to easily work with the API using intuitive and simple syntax. It requires a Personal Access Token for authentication, and gives you access to all of the features and functionality of the Linode API that are documented here with CLI examples. Endpoints that do not have CLI examples are currently unavailable through the CLI, but can be accessed via other methods such as Shell commands and other third-party applications.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "Linode",
      "documentation_url": "https://linode.com",
      "version": "4.151.1",
      "openapi_version": "3.0.1",
      "quality_score": 100,
      "is_popular": false,
      "title": "Linode API",
      "paths_count": 226,
      "schemas_count": 114
    }
  },
  {
    "name": "linqr",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/linqr.app/2.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "This is LinQR QR Code API documentation. This API allows you to generate custom, visually attractive QR Codes. The cloud infrastructure guarantees high availability and autoscalability of the service. You can generate hundreds of thousands of images this way and use them however you like. We realize that your API use case may require custom solutions, and perhaps we lack functionality that is very important to you. In that case feel free to write an email to our support and tell us about it. We have repeatedly added new functions of our service directly after the requests of our users. General remarks: - maximum request size is fixed at 32MB. - request timeout is fixed at 180 seconds.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "LinQR",
      "documentation_url": "https://linqr.app",
      "version": "2.0",
      "openapi_version": "3.0.2",
      "quality_score": 100,
      "is_popular": false,
      "title": "LinQR",
      "paths_count": 12,
      "schemas_count": 72
    }
  },
  {
    "name": "listen_api_podcast_search_directory_and_insights_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/listennotes.com/2.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Simple & no-nonsense podcast search & directory API. Search all podcasts and episodes by people, places, or topics.",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Listen Notes",
      "documentation_url": "https://www.listennotes.com/api/",
      "version": "2.0",
      "openapi_version": "3.1.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Listen API: Podcast Search, Directory, and Insights API",
      "paths_count": 23,
      "schemas_count": 102
    }
  },
  {
    "name": "api_docs_logoraisr_com",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/logoraisr.com/v1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Dig into our logoraisr API reference documentation. We also offer an OpenAPI specification to allow easy integration into your systems. You can download the json file by clicking on the download button.OpenAPI 2.0 Validation Status",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "logoraisr.com",
      "documentation_url": "https://logoraisr.com",
      "version": "v1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "API docs | logoraisr.com",
      "paths_count": 8,
      "schemas_count": 12
    }
  },
  {
    "name": "mandrill",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/mandrillapp.com/1.0/swagger.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Mandrill is a reliable, scalable, and secure delivery API for transactional emails from websites and applications. It's ideal for sending data-driven transactional emails, including targeted e-commerce and personalized one-to-one messages.",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "mandrillapp.com",
      "documentation_url": "https://mandrillapp.com/api/docs/",
      "version": "1.0",
      "openapi_version": "2.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Mandrill",
      "paths_count": 90,
      "schemas_count": 95
    }
  },
  {
    "name": "rat_genome_database_rest_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/mcw.edu/1.1/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The RGD REST API provides programmatic access to information and annotation stored in the Rat Genome Database",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Rat Genome Database",
      "documentation_url": "http://rgd.mcw.edu",
      "version": "1.1",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Rat Genome Database REST API",
      "paths_count": 100,
      "schemas_count": 24
    }
  },
  {
    "name": "medium_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/medium.com/1.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "Medium API helps you to quickly extract data from Medium's Website (https://medium.com). You can gather data related to users, publications, articles (including its textual content), latest posts &amp; top writers within a topic/niche, etc…",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Nishu Jain",
      "documentation_url": "https://github.com/Medium/medium-api-docs",
      "version": "1.0",
      "openapi_version": "3.0.2",
      "quality_score": 100,
      "is_popular": false,
      "title": "Medium API",
      "paths_count": 32,
      "schemas_count": 0
    }
  },
  {
    "name": "meraki_dashboard_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/meraki.com/1.32.0/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification. Date: 05 April, 2023 Recent Updates --- API Documentation Community Support Meraki Homepage",
      "category": "Development Tools",
      "last_updated": "2025-08-03",
      "maintainer": "Meraki Developer Community",
      "documentation_url": "https://meraki.io/community",
      "version": "1.32.0",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Meraki Dashboard API",
      "paths_count": 388,
      "schemas_count": 0
    }
  },
  {
    "name": "meshery_api",
    "provider_type": "http",
    "http_method": "GET",
    "url": "https://raw.githubusercontent.com/APIs-guru/openapi-directory/main/APIs/meshery.local/0.4.27/openapi.yaml",
    "content_type": "application/x-yaml",
    "metadata": {
      "description": "the purpose of this application is to provide an application that is using plain go code to define an API This should demonstrate all the possible comment annotations that are available to turn go code into a fully compliant swagger 2.0 spec",
      "category": "AI & Machine Learning",
      "last_updated": "2025-08-03",
      "maintainer": "meshery.local",
      "documentation_url": "https://meshery.local",
      "version": "0.4.27",
      "openapi_version": "3.0.0",
      "quality_score": 100,
      "is_popular": false,
      "title": "Meshery API.",
      "paths_count": 51,
      "schemas_count": 136
    }
  }
]